(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{381:function(t,n,a){"use strict";a.r(n);var e=a(4),s=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"进度条优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#进度条优化"}},[t._v("#")]),t._v(" 进度条优化")]),t._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/w8jmLDqSG-aSU4cS7U02nA",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/w8jmLDqSG-aSU4cS7U02nA"),n("OutboundLink")],1)])]),t._v(" "),n("h1",{attrs:{id:"part1前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part1前言"}},[t._v("#")]),t._v(" Part1前言")]),t._v(" "),n("p",[t._v("大家好，我是零一。最近我准备在组里进行代码串讲，所以我梳理了下项目之前的业务代码。在梳理的过程中，我看到了有个"),n("strong",[t._v("进度条组件")]),t._v("写的非常好，这又想起我刚开始学前端时写的进度条的代码，跟这个比起来真的差距太大了（大部分的初学者应该都想不到，而且我第一次实习的公司带我的mentor亦是如此）。")]),t._v(" "),n("p",[t._v("因此，我想给大家分享一下这个"),n("strong",[t._v("思路极好")]),t._v("的"),n("strong",[t._v("进度条组件")]),t._v("，同时它也存在"),n("strong",[t._v("非常严重")]),t._v("的性能问题，本文末尾也会讲解一下"),n("strong",[t._v("问题所在")]),t._v("以及"),n("strong",[t._v("优化方式")])]),t._v(" "),n("h1",{attrs:{id:"part2进度条的应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part2进度条的应用场景"}},[t._v("#")]),t._v(" Part2进度条的应用场景")]),t._v(" "),n("p",[t._v("一般进度条组件都出现在类似抖音播放视频的这样场景中，如图中底部的箭头所示：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/gMvNo9rxo42ucMKfnEZsfRVv28cGjfPpbRxQJgFFh4p6ibgFflEENGNN1sLRsta02XiabiarMWP3eJa2R4mD2MzGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),n("p",[t._v("进度条随着视频的长度而进行增长，视频暂停，进度条的动画也会随之暂停")]),t._v(" "),n("p",[t._v("接下来看看大部分人是怎么写的，为什么说思路和性能不好。这里以React为例，Vue开发者也不用怕看不懂，主要是看思路")]),t._v(" "),n("p",[t._v("主要实现功能：")]),t._v(" "),n("ul",[n("li",[t._v("支持播放、暂停、重播")]),t._v(" "),n("li",[t._v("播放结束后，播放次数+1，并重新开始播放")])]),t._v(" "),n("h1",{attrs:{id:"part3不推荐的写法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part3不推荐的写法"}},[t._v("#")]),t._v(" Part3不推荐的写法")]),t._v(" "),n("p",[n("strong",[t._v("组件部分")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// index.jsx\nimport { useState } from 'react'\nimport './index.css'\n\nlet timer = null  //  递增进度的定时器\nlet totalTime = 3000  // 假设视频播放为3s\n\nfunction App() {\n    const [progress, setProgress] = useState(0)  // 进度\n    const [isPlay, setIsPlay] = useState(false)  // 是否播放\n    \n    // setProgress的递增逻辑\n    const handlerProgress = pre => {\n        if(pre < 100) return pre + 1;\n        else {  \n          alert('播放结束')\n          return 0   // 播放结束，重新开始播放\n        }\n    }\n    \n    // 开始播放 && 暂停播放\n    const handleVideo = () => {\n        setIsPlay(!isPlay)\n        isPlay\n        ? clearInterval(timer)\n        : timer = setInterval(() => setProgress(handlerProgress), totalTime / 100)\n    }\n    \n    // 重播\n    const replay = () => {\n        setIsPlay(true)\n        if(timer) clearInterval(timer);\n        setProgress(0)\n        timer = setInterval(() => setProgress(handlerProgress), totalTime / 100)\n    }\n    \n    return (\n        <div id=\"root\">\n            <button onClick={handleVideo}>{ isPlay ? '暂停' : '播放' }</button>\n            <button onClick={replay}>重播</button>\n            <div className=\"container\">\n                <div className=\"progress\" style={{ width: `${progress}%` }}/>\n            </div>\n        </div>\n    )\n}\n")])])]),n("p",[n("strong",[t._v("样式部分")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(".container {\n    height: 10px;\n    border-radius: 5px;\n    border: 1px solid black;\n}\n\n.progress {\n    height: 100%;\n    width: 0;\n    background-color: red;\n}\n")])])]),n("p",[t._v("来简单演示一下这个进度条的样子")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_gif/gMvNo9rxo42ucMKfnEZsfRVv28cGjfPpRktTcDkQ0wkVyH7BkdDHo2qhpPic95IZISfic6EPRoCtjY09VzFpiaPibw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),n("p",[t._v("为什么说这种写法不太好呢？因为我们是通过定时器来快速递增变量"),n("code",[t._v("progress")]),t._v("以此来实现进度增加的，变量每次改变都会驱动视图重新计算渲染，这必然是性能很差的（说实话，我在体验这个demo的时候，肉眼可见的小卡顿）")]),t._v(" "),n("p",[t._v("除此之外呢？其实还有一个造成卡顿的原因，你们不妨猜猜看，我们放到最后一起讲，想知道答案的小伙伴可以直接滑到下面")]),t._v(" "),n("h1",{attrs:{id:"part4推荐的写法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part4推荐的写法"}},[t._v("#")]),t._v(" Part4推荐的写法")]),t._v(" "),n("p",[t._v("这里推荐的就是我在阅读代码时看到的比较优秀的方案了，接下来分享给大家")]),t._v(" "),n("p",[n("strong",[t._v("组件部分")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// index.jsx\nimport { useState } from 'react'\nimport './index.css'\n\nlet totalTime = 3000  // 假设视频播放为3s\n\nfunction App() {\n    const [isPlay, setIsPlay] = useState(false)  // 是否播放\n    const [count, setCount] = useState(0)  // 播放次数\n    const [type, setType] = useState(0)   // 使用哪个动画。0: @keyframes play; 1: @keyframes replay;\n    \n    // 暂停 && 播放\n    const handleVideo = () => setIsPlay(!isPlay);\n    \n    // 重播\n    const replay = () => {\n        setIsPlay(true)\n        setType(type ? 0 : 1)\n    }\n    \n    // 动画结束时触发的事件\n    const end = () => {\n        setCount(count + 1)  // 播放次数 +1\n        replay()   // 重新开始播放\n    }\n    \n    return (\n        <div id=\"root\">\n            <button onClick={handleVideo}>{ isPlay ? '暂停' : '播放' }</button>\n            <button onClick={replay}>重播</button>\n            <span>{ `播放次数为：${count}` }</span>\n            <div className=\"container\">\n                <div \n                    className={`progress ${isPlay ? 'play' : 'pause'}`} \n                    style={{\n                        animationDuration: `${totalTime}ms`,\n                        animationName: `${type ? 'replay' : 'play'}`\n                    }}\n                    onAnimationEnd={end}  // 动画结束时的事件\n                />\n            </div>\n        </div>\n    )\n}\n")])])]),n("p",[n("strong",[t._v("样式部分")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@keyframes play {   \n    to {\n        width: 100%;\n    }\n}\n\n@keyframes replay {\n    to {\n        width: 100%;\n    }\n}\n\n.container {\n    height: 10px;\n    border-radius: 5px;\n    border: 1px solid black;\n}\n\n.progress {\n    height: 100%;\n    width: 0;\n    background-color: red;\n    animation-timing-function: linear;\n}\n\n.progress.play {     /* 使animation动画启动 */\n    animation-play-state: running;\n}\n\n.progress.pause {    /* 使animation动画暂停 */\n    animation-play-state: paused;\n}\n")])])]),n("p",[t._v("我们设置了两个"),n("code",[t._v("@keyframes")]),t._v('动画是为了在使进度条重新播放时可以做一个切换，即点击 "重播" 时，直接切换到另一个动画，就可以实现进度条从0开始递增')]),t._v(" "),n("p",[t._v("同时我们还设置了两个类名的样式，分别用于控制动画的播放和暂停")]),t._v(" "),n("p",[t._v("播放完成时，播放次数+1的功能可以通过事件"),n("code",[t._v("animationend")]),t._v("来监听即可")]),t._v(" "),n("p",[t._v("同样的，来看一下这套方案的效果图（跟前一套方案功能一模一样）")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("对比一下前一套方案，你就能知道这种写法不需要去一直修改数据来驱动视图的改变，减少了框架内的大量计算，提升了不少的性能")]),t._v(" "),n("h1",{attrs:{id:"part5缺陷"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part5缺陷"}},[t._v("#")]),t._v(" Part5缺陷")]),t._v(" "),n("p",[t._v("第二种方案虽然性能很好，但是与第一种方案一样，存在另外一个隐藏的性能问题，这也是我在排查前同事代码性能问题时所发现的。")]),t._v(" "),n("p",[n("strong",[t._v("缺陷：这两种方案都会引发频繁的重排和重绘")])]),t._v(" "),n("p",[t._v("可以借助"),n("code",[t._v("chrome devtools performance")]),t._v("来验证一下页面的情况")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("小小的一个进度条触发了那么那么多次重排和重绘，那么它到底有什么影响呢？来简单回顾一下重排和重绘的影响")]),t._v(" "),n("p",[n("strong",[t._v("重排")]),t._v("：浏览器需要重新计算元素的几何属性，而且其他元素的几何属性或位置可能也会因此改变受到影响。")]),t._v(" "),n("p",[n("strong",[t._v("重绘")]),t._v("：不是所有的DOM变化都影响元素的几何属性，如果改变元素的背景色并不影响它的宽度和高度，这种情况，只会发生一次重绘，而不会发生重排，因为元素的布局没改变")]),t._v(" "),n("p",[t._v("所以知道了重排和重绘造成的严重问题后，我们马上对其进行分析优化")]),t._v(" "),n("h1",{attrs:{id:"part6极致的优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part6极致的优化"}},[t._v("#")]),t._v(" Part6极致的优化")]),t._v(" "),n("p",[t._v("先来看看一个非常常见的图"),n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("页面的渲染，大体上走的就是这5个流程。当然也有办法跳过中间某些步骤，例如避免"),n("code",[t._v("Layout")]),t._v("和"),n("code",[t._v("Paint")])]),t._v(" "),n("p",[t._v("再来回顾一下有哪些方法会引起重排和重绘吧")]),t._v(" "),n("p",[n("strong",[t._v("触发重排的因素")]),t._v("：添加或删除可见的DOM元素、改变元素位置、元素的尺寸改变（包括：外边距、内边距、边框、高度等）、内容改变（如：文本改变或图片被另外一个不同尺寸的图片替代）、浏览器窗口尺寸的改变、通过"),n("code",[t._v("display: none")]),t._v("隐藏⼀个DOM节点等")]),t._v(" "),n("p",[n("strong",[t._v("触发重绘的因素")]),t._v("：重排必定触发重绘（重要）、通过"),n("code",[t._v("visibility: hidden")]),t._v("隐藏⼀个DOM节点、修改元素背景色、修改字体颜色等")]),t._v(" "),n("p",[t._v("那么我们前面写的代码中到底是哪里触发了重排和重绘呢？简单检查一下，不难发现两种方案都是在不停改变元素的"),n("code",[t._v("width")]),t._v("，元素的宽度一改变必然会引起重排和重绘，更何况是超频繁的改变呢！")]),t._v(" "),n("p",[n("strong",[t._v("解决方案：启用GPU加速，避开重排和重绘的环节，将进度条单独提升到一个图层，即不影响其它元素")])]),t._v(" "),n("p",[t._v("就单独针对第二种方案进行优化吧~我们只需要改动其css内容即可（标注出即为改动处）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("@keyframes play {     /* 通过transform来启用GPU加速，跳过重排重绘阶段 */\n    0% {  \n        transform: translateX(-50%) scaleX(0);  /* 用 scaleX 来代替 width */\n    }\n\n    to {\n        transform: translateX(0) scaleX(1);\n    }\n}\n\n@keyframes replay {\n    0% {\n        transform: translateX(-50%) scaleX(0);\n    }\n\n    to {\n        transform: translateX(0) scaleX(1);\n    }\n}\n\n.container {\n    height: 10px;\n    border-radius: 5px;\n    border: 1px solid black;\n}\n\n.progress {\n    height: 100%;\n    width: 100%;   /* 初始宽度为100%，因为我们要对其缩放 */\n    background-color: red;\n    will-change: transform;   /* 通过will-change告知浏览器提前做好优化准备 */\n    animation-timing-function: linear;\n}\n\n.progress.play {    \n    animation-play-state: running;\n}\n\n.progress.pause {   \n    animation-play-state: paused;\n}\n")])])]),n("p",[t._v("这里简单解释一下"),n("code",[t._v("translateX")]),t._v("和"),n("code",[t._v("scaleX")]),t._v("的数值设置。设置进度条"),n("code",[t._v("width: 100%")]),t._v("，我们通过"),n("code",[t._v("scaleX(0.5)")]),t._v("将其缩放一半，可以发现进度条长度为容器的一半且居中，此时我们就需要通过"),n("code",[t._v("translateX(-25%)")]),t._v("将其向左平移到最左端，为什么是"),n("code",[t._v("-25%")]),t._v("呢？因为进度条占了容器的一半且居中，表明左右的留白正好分别是"),n("code",[t._v("(100% - 50%) / 2 = 25%")]),t._v("，所以也不难得知当初始状态"),n("code",[t._v("scaleX(0)")]),t._v("时，"),n("code",[t._v("translateX")]),t._v("的值为"),n("code",[t._v("-(100% - 0%) / 2 = -50%")])]),t._v(" "),n("p",[t._v("这么做了以后，我们再次用"),n("code",[t._v("performance")]),t._v("检验一下")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("可以很明显地看到页面重排重绘的次数减少了很多很多，剩余的基本都是页面最基本的重排和重绘了。")]),t._v(" "),n("p",[t._v("有人要说我标题党了，接下来给你们展示一下到底优化了多少性能")]),t._v(" "),n("p",[t._v("先用刚极致优化完的跑一下"),n("code",[t._v("performance")])]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("看图中右侧，FPS基本是稳定在"),n("code",[t._v("55 ~ 70")]),t._v("之间")]),t._v(" "),n("p",[t._v("再来看看文章开头第一种方案的"),n("code",[t._v("performance")]),t._v("跑分")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("看图中右侧，FPS基本是稳定在"),n("code",[t._v("32 ~ 50")]),t._v("之间")]),t._v(" "),n("p",[t._v("可以很清楚得看到，优化前的FPS波动非常严重，即不够稳定，所以容易出现卡顿问题；而优化后的FPS的变化是不大的，整体变化趋势比较平，几乎是一直线")]),t._v(" "),n("p",[t._v("在这样一个极简页面中，我们优化后性能都大约提升了大约"),n("code",[t._v("40% ~ 54%")])]),t._v(" "),n("p",[t._v("那么如果在正常的项目中，考虑到页面的复杂性，我们优化后的方案既避免了页面反复得计算渲染，又避免了重绘回流，可想而知在那种情形下性能的提升应该是远不止"),n("code",[t._v("40% ~ 54%")]),t._v("的，emmmmmm，所以我说性能提高70%应该也不是很过分吧 hhhhh")]),t._v(" "),n("h1",{attrs:{id:"part7小彩蛋"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#part7小彩蛋"}},[t._v("#")]),t._v(" Part7小彩蛋")]),t._v(" "),n("p",[t._v("启用GPU加速会将元素提升到单独的一个图层中，我们可以通过"),n("code",[t._v("chrome devtools layers")]),t._v("来查看")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("这里就分别展示一下我们优化前和优化后的页面分层情况吧")]),t._v(" "),n("p",[n("strong",[t._v("「优化前」")])]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("很明显地看到，整个页面就只有"),n("code",[t._v("document")]),t._v("层，即进度条没有被分层出来")]),t._v(" "),n("p",[n("strong",[t._v("「优化后」")])]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("同样也很明显地可以看到，进度条被单独分出来一个图层了")])])}),[],!1,null,null,null);n.default=s.exports}}]);