(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{387:function(t,e,n){"use strict";n.r(e);var s=n(4),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react事件绑定的方式有哪些-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react事件绑定的方式有哪些-区别"}},[t._v("#")]),t._v(" React事件绑定的方式有哪些？区别？")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibRwHHk6DfiaJ78aX4pHcs1xZZCnhGfjMWU3QVtxoO8XpB2Y9HdJbP6bZMCpETVTdPBibS6ficDeOowWg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),e("h2",{attrs:{id:"一、是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、是什么"}},[t._v("#")]),t._v(" 一、是什么")]),t._v(" "),e("p",[t._v("在"),e("code",[t._v("react")]),t._v("应用中，事件名都是用小驼峰格式进行书写，例如"),e("code",[t._v("onclick")]),t._v("要改写成"),e("code",[t._v("onClick")])]),t._v(" "),e("p",[t._v("最简单的事件绑定如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class ShowAlert extends React.Component {\n  showAlert() {\n    console.log("Hi");\n  }\n\n  render() {\n    return <button onClick={this.showAlert}>show</button>;\n  }\n}\n')])])]),e("p",[t._v("从上面可以看到，事件绑定的方法需要使用"),e("code",[t._v("{}")]),t._v("包住")]),t._v(" "),e("p",[t._v("上述的代码看似没有问题，但是当将处理函数输出代码换成"),e("code",[t._v("console.log(this)")]),t._v("的时候，点击按钮，则会发现控制台输出"),e("code",[t._v("undefined")])]),t._v(" "),e("h2",{attrs:{id:"二、如何绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、如何绑定"}},[t._v("#")]),t._v(" 二、如何绑定")]),t._v(" "),e("p",[t._v("为了解决上面正确输出"),e("code",[t._v("this")]),t._v("的问题，常见的绑定方式有如下：")]),t._v(" "),e("ul",[e("li",[t._v("render方法中使用bind")]),t._v(" "),e("li",[t._v("render方法中使用箭头函数")]),t._v(" "),e("li",[t._v("constructor中bind")]),t._v(" "),e("li",[t._v("定义阶段使用箭头函数绑定")])]),t._v(" "),e("h3",{attrs:{id:"_1-render方法中使用bind"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-render方法中使用bind"}},[t._v("#")]),t._v(" ① render方法中使用bind")]),t._v(" "),e("p",[t._v("如果使用一个类组件，在其中给某个组件/元素一个"),e("code",[t._v("onClick")]),t._v("属性，它现在并会自定绑定其"),e("code",[t._v("this")]),t._v("到当前组件，解决这个问题的方法是在事件函数后使用"),e("code",[t._v(".bind(this)")]),t._v("将"),e("code",[t._v("this")]),t._v("绑定到当前组件中")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class App extends React.Component {\n  handleClick() {\n    console.log('this > ', this);\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick.bind(this)}>test</div>\n    )\n  }\n}\n")])])]),e("p",[t._v("这种方式在组件每次"),e("code",[t._v("render")]),t._v("渲染的时候，都会重新进行"),e("code",[t._v("bind")]),t._v("的操作，影响性能")]),t._v(" "),e("h3",{attrs:{id:"_2-render方法中使用箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-render方法中使用箭头函数"}},[t._v("#")]),t._v(" ② render方法中使用箭头函数")]),t._v(" "),e("p",[t._v("通过"),e("code",[t._v("ES6")]),t._v("的上下文来将"),e("code",[t._v("this")]),t._v("的指向绑定给当前组件，同样在每一次"),e("code",[t._v("render")]),t._v("的时候都会生成新的方法，影响性能")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class App extends React.Component {\n  handleClick() {\n    console.log('this > ', this);\n  }\n  render() {\n    return (\n      <div onClick={e => this.handleClick(e)}>test</div>\n    )\n  }\n}\n")])])]),e("h2",{attrs:{id:"_3-constructor中bind"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-constructor中bind"}},[t._v("#")]),t._v(" ③ constructor中bind")]),t._v(" "),e("p",[t._v("在"),e("code",[t._v("constructor")]),t._v("中预先"),e("code",[t._v("bind")]),t._v("当前组件，可以避免在"),e("code",[t._v("render")]),t._v("操作中重复绑定")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    console.log('this > ', this);\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}>test</div>\n    )\n  }\n}\n")])])]),e("h3",{attrs:{id:"_4-定义阶段使用箭头函数绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-定义阶段使用箭头函数绑定"}},[t._v("#")]),t._v(" ④ 定义阶段使用箭头函数绑定")]),t._v(" "),e("p",[t._v("跟上述方式三一样，能够避免在"),e("code",[t._v("render")]),t._v("操作中重复绑定，实现也非常的简单，如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class App extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  handleClick = () => {\n    console.log('this > ', this);\n  }\n  render() {\n    return (\n      <div onClick={this.handleClick}>test</div>\n    )\n  }\n}\n")])])]),e("h2",{attrs:{id:"三、区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、区别"}},[t._v("#")]),t._v(" 三、区别")]),t._v(" "),e("p",[t._v("上述四种方法的方式，区别主要如下：")]),t._v(" "),e("ul",[e("li",[t._v("编写方面：方式一、方式二写法简单，方式三的编写过于冗杂")]),t._v(" "),e("li",[t._v("性能方面：方式一和方式二在每次组件render的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例")])]),t._v(" "),e("p",[t._v("综合上述，方式四是最优的事件绑定方式")]),t._v(" "),e("h2",{attrs:{id:"参考文献"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),e("ul",[e("li",[t._v("https://segmentfault.com/a/1190000011317515")])])])}),[],!1,null,null,null);e.default=a.exports}}]);