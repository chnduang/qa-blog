(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{330:function(t,s,l){"use strict";l.r(s);var n=l(4),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"为什么-http1-1-不能实现多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-http1-1-不能实现多路复用"}},[t._v("#")]),t._v(" 为什么 HTTP1.1 不能实现多路复用")]),t._v(" "),s("p",[t._v("HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用")]),t._v(" "),s("p",[t._v("HTTP1.x是序列和阻塞机制")]),t._v(" "),s("p",[t._v('HTTP 2.0 是多工复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。')]),t._v(" "),s("ul",[s("li",[t._v("举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。")]),t._v(" "),s("li",[t._v("旧的http1.1是会等 A请求完全处理完后在 处理B请求，会阻塞")]),t._v(" "),s("li",[t._v("另：http1.1已经实现了管道机制：即 在同一个TCP连接里面，客户端可以同时发送多个请求。http 1.0并做不到，所以效率很低")])])])}),[],!1,null,null,null);s.default=r.exports}}]);