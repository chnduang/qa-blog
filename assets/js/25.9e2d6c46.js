(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{317:function(n,e,a){"use strict";a.r(e);var t=a(4),s=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"leetcode最常见的150道前端面试题-简单题上"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#leetcode最常见的150道前端面试题-简单题上"}},[n._v("#")]),n._v(" leetcode最常见的150道前端面试题（简单题上）")]),n._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/G_SThofkcSUcuX44UbF9kA",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://mp.weixin.qq.com/s/G_SThofkcSUcuX44UbF9kA"),e("OutboundLink")],1)])]),n._v(" "),e("h2",{attrs:{id:"举例-存在重复元素-类似题还有3道-后面一起说-解法一样"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#举例-存在重复元素-类似题还有3道-后面一起说-解法一样"}},[n._v("#")]),n._v(" 举例：存在重复元素（类似题还有3道，后面一起说，解法一样）")]),n._v(" "),e("p",[n._v("题目描述如下：")]),n._v(" "),e("p",[n._v("给定一个整数数组，判断是否存在重复元素。")]),n._v(" "),e("p",[n._v("如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1:\n\n输入: [1,2,3,1]\n输出: true\n\n示例 2:\n\n输入: [1,2,3,4]\n输出: false\n复制代码\n")])])]),e("p",[n._v("这题一看就是 计数问题，题目中"),e("code",[n._v("如果存在一值在数组中出现至少两次")]),n._v("，这句话就告诉我们记录每一个数字出现的次数就能解决问题了。")]),n._v(" "),e("h4",{attrs:{id:"解决思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决思路"}},[n._v("#")]),n._v(" 解决思路：")]),n._v(" "),e("p",[n._v("我们遍历数组时，经过数组中的每一项就往map中添加，比如[1,2,3,1]")]),n._v(" "),e("ul",[e("li",[n._v("第一项：遍历到第一个1时，对象返回"),e("code",[n._v("{ 1: 1 }")]),n._v(",代表1出现1次")]),n._v(" "),e("li",[n._v("第二项：遍历到2时，返回 "),e("code",[n._v("{ 1: 1, 2: 1 }")])]),n._v(" "),e("li",[n._v("第三项：遍历到3时，返回 "),e("code",[n._v("{ 1: 1, 2: 1， 3: 1 }")])]),n._v(" "),e("li",[n._v("第四项：遍历到第二个1时，发现原来的对象里已经有1了，返回"),e("code",[n._v("false")])])]),n._v(" "),e("p",[n._v("所以，代码自然也就出来了，如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const containsDuplicate = function(nums) {\n    let map = new Map();\n    for(let i of nums){\n        if(map.has(i)){\n            return true;\n        }else{\n            map.set(i, 1);\n        }\n    }\n    return false;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"哈希表-计数类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希表-计数类型"}},[n._v("#")]),n._v(" 哈希表 + 计数类型")]),n._v(" "),e("p",[n._v("除了上面的那道题，在最热门的简单题型中还有一些记数类型的题，我们一一解答，这是一类题型")]),n._v(" "),e("h2",{attrs:{id:"_387-字符串中的第一个唯一字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_387-字符串中的第一个唯一字符"}},[n._v("#")]),n._v(" 387. 字符串中的第一个唯一字符")]),n._v(" "),e("p",[n._v("一看题目，唯一，条件反射，记数题啊，map走起！我们先看一下题目：")]),n._v(" "),e("p",[n._v("给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例：\n\ns = "leetcode"\n返回 0\n\ns = "loveleetcode"\n返回 2\n \n// 提示：你可以假定该字符串只包含小写字母\n复制代码\n')])])]),e("p",[n._v("思路：")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("遍历字符串")])]),n._v(" "),e("li",[e("p",[n._v("用一个对象"),e("code",[n._v("{}")]),n._v("来记数，出现过一次就"),e("code",[n._v("+1")]),n._v("，")])]),n._v(" "),e("li"),n._v(" "),e("li",[e("ul",[e("li",[n._v("遍历完毕，再次遍历字符串，看它们在之前记录的对象里的值，是否是1，是就返回下标，不是返回-1。")])])])]),n._v(" "),e("p",[n._v("参考答案：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var firstUniqChar = function(s) {\n  const map = {};\n  for(let v of s) map[v] = (map[v] || 0) + 1;\n  for(let i = 0; i < s.length; i++) if(map[s[i]] === 1) return i;\n  return -1;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_242-有效的字母异位词"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_242-有效的字母异位词"}},[n._v("#")]),n._v(" 242. 有效的字母异位词")]),n._v(" "),e("p",[n._v("我们先看一下题目：")]),n._v(" "),e("p",[n._v("给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。")]),n._v(" "),e("p",[n._v("注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例 1:\n\n输入: s = "anagram", t = "nagaram"\n输出: true\n示例 2:\n\n输入: s = "rat", t = "car"\n输出: false\n复制代码\n')])])]),e("p",[n._v("思路：这个题一看字眼，出现次数相同，次数不就是记数吗，记数题型，map走起！")]),n._v(" "),e("ul",[e("li",[n._v("声明计数器，一个对象 "),e("code",[n._v("const obj = {}")])]),n._v(" "),e("li",[n._v("遍历s字符串，如果遍历到字符串的"),e("code",[n._v("'a'")]),n._v("字母，去看"),e("code",[n._v("obj[a]")]),n._v("是否存在")]),n._v(" "),e("li",[n._v("不存在说明第一次遍历到"),e("code",[n._v("'a'")]),n._v("字母，那么初始化"),e("code",[n._v("obj[a] = 1")])]),n._v(" "),e("li",[n._v("如果存在则"),e("code",[n._v("obj[a] += 1")])]),n._v(" "),e("li",[n._v("t字符串同理，它每次"),e("code",[n._v("减1")])]),n._v(" "),e("li",[n._v("遍历完s字符串后，遍历obj对象，看它的每一对"),e("code",[n._v("key：value")]),n._v("，是否"),e("code",[n._v("value")]),n._v("都是"),e("code",[n._v("0")])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var isAnagram = function(s, t) {\n\n  const sLen = s.length;\n  const tLen = t.length;\n  if(sLen !== tLen ) {\n      return false;\n  }\n  const obj = {};\n  for(let i = 0 ; i < sLen ; i++){\n      const currentS = s[i];\n      const currentT = t[i];\n      obj[currentS] ? obj[currentS]++ : obj[currentS] = 1;\n      obj[currentT] ? obj[currentT]-- : obj[currentT] = -1;\n  }\n  return Object.values(obj).every(v=>v===0);\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_169-多数元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_169-多数元素"}},[n._v("#")]),n._v(" 169. 多数元素")]),n._v(" "),e("p",[n._v("我们先看题目（题目里有次数两个字，又是记数题型，map继续走起）：")]),n._v(" "),e("p",[n._v("给定一个大小为 "),e("code",[n._v("n")]),n._v(" 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 "),e("code",[n._v("⌊ n/2 ⌋")]),n._v(" 的元素。")]),n._v(" "),e("p",[n._v("你可以假设数组是非空的，并且给定的数组总是存在多数元素。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：[3,2,3]\n输出：3\n示例 2：\n\n输入：[2,2,1,1,1,2,2]\n输出：2\n复制代码\n")])])]),e("p",[n._v("思路：")]),n._v(" "),e("ul",[e("li",[n._v("声明一个计数器,也就是一个对象"),e("code",[n._v("const map = {}")])]),n._v(" "),e("li",[n._v("遍历字符串，开始记数，如果字符串的字母第一次碰见，"),e("code",[n._v("map[第一次碰见的字母] = 1")])]),n._v(" "),e("li",[n._v("如果map已经记录过这个字母，则"),e("code",[n._v("map[记录过的的字母] += 1")])]),n._v(" "),e("li",[n._v("在遍历的过程中，看"),e("code",[n._v("map[记录过的的字母]")]),n._v(" 是否大于 "),e("code",[n._v("数组总长度/2")])])]),n._v(" "),e("p",[n._v("解答：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var majorityElement = function(nums) {\n  const map = {}\n  const n = nums.length >> 1 // >>是右移运算符，意思是除以2\n  for(let i = 0; i < nums.length; i++){\n      map[nums[i]] = map[nums[i]] !== undefined ? map[nums[i]] + 1 : 1\n      if(map[nums[i]] > n) return nums[i]\n  }\n}\n复制代码\n")])])]),e("h2",{attrs:{id:"只出现一次的数字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#只出现一次的数字"}},[n._v("#")]),n._v(" 只出现一次的数字")]),n._v(" "),e("p",[n._v("这个题一看，出现一次，map走起，但是呢，这个题比较巧的是，因为题目的一些限制条件，可以有更好的解法，我们先看题：")]),n._v(" "),e("p",[n._v("给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。")]),n._v(" "),e("p",[n._v("说明：")]),n._v(" "),e("p",[n._v("你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1:\n\n输入: [2,2,1]\n输出: 1\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n复制代码\n")])])]),e("p",[n._v("这里我们用"),e("code",[n._v("map")]),n._v("记录一遍，类似这样的代码，")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const countMap = {};\n数组.forEach((item)=> { countMap[item] ? countMap[item] += 1 : countMap[item] = 1 } )\n最后再遍历一次countMap，然后看谁的次数是`1`，就解决了\n复制代码\n")])])]),e("p",[n._v("但是这套题有另一个解法，用异或运算符，首先我们看看异或运算符有啥用：")]),n._v(" "),e("p",[n._v("异或运算符"),e("code",[n._v("(^)")]),n._v("，我们了解下，这个运算符的功能")]),n._v(" "),e("ul",[e("li",[n._v("任何数和自己做异或运算，结果为 "),e("code",[n._v("0")]),n._v("，即 "),e("code",[n._v("a⊕a=0")]),n._v("。")]),n._v(" "),e("li",[n._v("任何数和 "),e("code",[n._v("0")]),n._v(" 做异或运算，结果还是自己，即 "),e("code",[n._v("a⊕0=a")]),n._v("。")]),n._v(" "),e("li",[n._v("异或运算中，满足交换律和结合律，也就是"),e("code",[n._v("a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b")]),n._v("。")])]),n._v(" "),e("p",[n._v("所以出现两次的字母异或运算得"),e("code",[n._v("0")]),n._v("，跟出现一次的字母异或运算得到自己")]),n._v(" "),e("p",[n._v("解答：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var singleNumber = function(nums) {\n  let init = nums[0];\n  for(let i = 1; i < nums.length; i++){\n      init ^=  nums[i];\n  }\n  return init;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"位1的个数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#位1的个数"}},[n._v("#")]),n._v(" 位1的个数")]),n._v(" "),e("p",[n._v("编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n示例 2：\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n复制代码\n")])])]),e("p",[n._v("思路：")]),n._v(" "),e("p",[n._v("计算个数，按照我们之前的思路，把整个数字转为字符串，类似这样：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("数字 0001 => String(0001) => '0001' => 遍历看1的个数\n复制代码\n")])])]),e("p",[n._v("然后直接遍历计算就可以了，这是我为什么把它归为记数类别的原因，当然也可以把它归为数学类，我们用数学的算法来解，先看答案，我们再解析。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var hammingWeight = function(n) {\n    let ret = 0;\n    while(n){\n        n &= (n - 1);\n        ret++;\n    }\n    return ret;\n};\n复制代码\n")])])]),e("p",[n._v("原理：")]),n._v(" "),e("p",[n._v("每执行一次"),e("code",[n._v("x = x & (x-1)")]),n._v("，会将"),e("code",[n._v("x")]),n._v("用二进制表示时最右边的一个"),e("code",[n._v("1")]),n._v("变为"),e("code",[n._v("0")]),n._v("，因为"),e("code",[n._v("x-1")]),n._v("将会将该位("),e("code",[n._v("x")]),n._v("用二进制表示时最右边的一个"),e("code",[n._v("1")]),n._v(")变为"),e("code",[n._v("0")]),n._v("。因此，对 "),e("code",[n._v("x")]),n._v(" 重复该操作，直到 "),e("code",[n._v("x")]),n._v(" 变成 "),e("code",[n._v("0")]),n._v("，则操作次数即为 "),e("code",[n._v("x")]),n._v(" 的二进制数中的 "),e("code",[n._v("1")]),n._v(" 的数目。")]),n._v(" "),e("p",[n._v("接下来，我们把其他类型的哈希表题也介绍了（相同的题型没那么多）")]),n._v(" "),e("h2",{attrs:{id:"哈希表-映射功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希表-映射功能"}},[n._v("#")]),n._v(" 哈希表 + 映射功能")]),n._v(" "),e("p",[n._v("哈希表有一个非常常见的功能就是建立映射关系，比如说设计模式里的策略模式，思路是一样的，映射表常常见于后端的枚举类型，typescript也是一样，我们举一个js的例子")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 后端只会返回0，1，2\nconst TYPE = {\n    2: 'orange',\n    1: 'red',\n    0: 'blue'\n}\n\n// 然后前端会这样用\nTYPE[后端返回的数字0或1或2]\n复制代码\n")])])]),e("h3",{attrs:{id:"对应的题有"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对应的题有"}},[n._v("#")]),n._v(" 对应的题有：")]),n._v(" "),e("ul",[e("li",[n._v("1.两数之和")]),n._v(" "),e("li",[n._v("349.两个数组的交集")])]),n._v(" "),e("h2",{attrs:{id:"两数之和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两数之和"}},[n._v("#")]),n._v(" 两数之和")]),n._v(" "),e("p",[n._v("给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。")]),n._v(" "),e("p",[n._v("你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。")]),n._v(" "),e("p",[n._v("你可以按任意顺序返回答案。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n复制代码\n")])])]),e("p",[n._v("用 hashMap 存储遍历过的元素和对应的索引。每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。所有事情在一次遍历中完成（用了空间换取时间）")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var twoSum = function(nums, target) {\n    const map = new Map();\n    for(let i = 0, len = nums.length; i < len; i++){\n        if(map.get(nums[i]) !== undefined){\n            return [map.get(nums[i]), i];\n        } else {\n            map.set(target - nums[i], i);\n        }\n    }\n    return [];\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"两数组交集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两数组交集"}},[n._v("#")]),n._v(" 两数组交集")]),n._v(" "),e("p",[n._v("题目如下：给定两个数组，编写一个函数来计算它们的交集。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2]\n示例 2：\n\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[9,4]\n \n\n说明：\n\n输出结果中的每个元素一定是唯一的。\n我们可以不考虑输出结果的顺序。\n复制代码\n")])])]),e("p",[n._v("这道题可以用set，很简单,但是空间复杂度和时间复杂度都太高，不太优雅")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var intersection = function (nums1, nums2) {\n    return result =[...new Set(nums1)].filter(item=>new Set(nums2).has(item))\n};\n复制代码\n")])])]),e("p",[n._v("我们可以用map来做，时间和空间复杂度都低很多 思路：")]),n._v(" "),e("ul",[e("li",[n._v("用一个map去存nums1数组里的每一项，类似"),e("code",[n._v("map[nums1[i]] = true")])]),n._v(" "),e("li",[n._v("然后去遍历nums2，如果在map中已经有的值，类似"),e("code",[n._v("map[nums2[i]]")]),n._v(", 就把它push到一个数组里")]),n._v(" "),e("li",[n._v("并且将map[nums2[i]]设为false，后面有相同的值就不push到数组了")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var intersection = function(nums1, nums2) {\n    const map = {};\n    const ret = [];\n    for(let i = 0; i < nums1.length; i++){\n        map[nums1[i]] = true;\n    }\n    for(let i = 0; i < nums2.length; i++){\n        if(map[nums2[i]]){\n            ret.push(nums2[i])\n            map[nums2[i]] = false\n        }\n    }\n    return ret;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"找规律题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#找规律题"}},[n._v("#")]),n._v(" 找规律题")]),n._v(" "),e("p",[n._v("这类题一般画个图或者稍微分析一下就能得出答案")]),n._v(" "),e("h2",{attrs:{id:"_13-罗马数字转整数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-罗马数字转整数"}},[n._v("#")]),n._v(" 13. 罗马数字转整数")]),n._v(" "),e("p",[n._v("这个题，我来简单描述一下，罗马数字对应我们阿拉伯数字的map如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("        I: 1,\n        V: 5,\n        IV: 4,\n        IX: 9,\n        X: 10,\n        XL: 40,\n        XC: 90,\n        L: 50,\n        C: 100,\n        CD: 400,\n        CM: 900,\n        D: 500,\n        M: 1000,\n复制代码\n")])])]),e("p",[n._v("题目是给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例 1:\n\n输入: "III"\n输出: 3\n示例 2:\n\n输入: "IV"\n输出: 4\n示例 3:\n\n输入: "IX"\n输出: 9\n示例 4:\n\n输入: "LVIII"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n复制代码\n')])])]),e("p",[n._v("解题思路就是我们发现这些案例的规律，就是把map表里面对应数字加起来就行了，比如说")]),n._v(" "),e("p",[e("code",[n._v('"LVIII"')]),n._v(" = "),e("code",[n._v("'L'")]),n._v("（对应map表50）+ "),e("code",[n._v("'V'")]),n._v("（对应map表5）+ "),e("code",[n._v("'I'")]),n._v("（对应map表1） + "),e("code",[n._v("'I'")]),n._v("对应map表1） + "),e("code",[n._v("'I'")]),n._v("（对应map表1）")]),n._v(" "),e("p",[n._v("所以解答就很简单了，就是遍历数字把对应的值加起来，如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var romanToInt = function(s) {\n    const map = {\n        I: 1,\n        V: 5,\n        IV: 4,\n        IX: 9,\n        X: 10,\n        XL: 40,\n        XC: 90,\n        L: 50,\n        C: 100,\n        CD: 400,\n        CM: 900,\n        D: 500,\n        M: 1000,\n    }\n    let res = 0;\n    let index = 0;\n    let len = s.length;\n    while(index < len){\n        if(index + 1 < len && map[s.slice(index, index+2)]){\n            res += map[s.slice(index, index+2)];\n            index += 2;\n        }else{\n            res += map[s.slice(index, index+1)];\n            index += 1;\n        }\n    }\n    return res;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_14-最长公共前缀"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-最长公共前缀"}},[n._v("#")]),n._v(" 14. 最长公共前缀")]),n._v(" "),e("p",[n._v("题目如下：")]),n._v(" "),e("p",[n._v("编写一个函数来查找字符串数组中的最长公共前缀。")]),n._v(" "),e("p",[n._v('如果不存在公共前缀，返回空字符串 ""。')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例 1：\n\n输入：strs = ["flower","flow","flight"]\n输出："fl"\n示例 2：\n\n输入：strs = ["dog","racecar","car"]\n输出：""\n解释：输入不存在公共前缀。\n \n\n提示：\n\n0 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] 仅由小写英文字母组成\n复制代码\n')])])]),e("p",[n._v("思路：这个题的思路就是，假如你求数组里3个元素的最长公共前缀")]),n._v(" "),e("ul",[e("li",[n._v("你先拿前两个比较，求出他们两个的最长公共前缀")]),n._v(" "),e("li",[n._v("然后上面求出的结果去跟第三个元素求最长公共前缀")]),n._v(" "),e("li",[n._v("n个元素就一直这么"),e("code",[n._v("reduce")]),n._v("下去")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 这个是求出两个元素最长公共前缀的方法\nvar longestCommonPrefix = function (strs) {\n  if (strs.length === 0) return ''\n  if (strs.length === 1) return strs[0];\n  return strs.reduce(getSameStr, strs[0]);\n};\n\nfunction getSameStr(a, b) {\n  let res = ''\n  for (let j = 0; j < a.length; j++) {\n    if (a[j] === b[j]) {\n      res += a[j];\n    } else {\n      return res;\n    }\n  }\n  return res\n}\n复制代码\n")])])]),e("h2",{attrs:{id:"_21-合并两个有序链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-合并两个有序链表"}},[n._v("#")]),n._v(" 21. 合并两个有序链表")]),n._v(" "),e("p",[n._v("这个题简而言之就是看图找规律，就是合并为升序链表，具体题目如下：")]),n._v(" "),e("p",[n._v("我们先看一下题目：")]),n._v(" "),e("p",[n._v("将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n示例 2：\n\n输入：l1 = [], l2 = []\n输出：[]\n示例 3：\n\n输入：l1 = [], l2 = [0]\n输出：[0]\n \n\n提示：\n\n两个链表的节点数目范围是 [0, 50]\n-100 <= Node.val <= 100\nl1 和 l2 均按 非递减顺序 排列\n复制代码\n")])])]),e("p",[n._v("思路:")]),n._v(" "),e("p",[n._v("那就挨个遍历，按顺序谁小拼接谁，接着进入下一轮循环，看代码更清晰一些：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 链表定义函数\nfunction ListNode(val, next) {\n    this.val = (val===undefined ? 0 : val)\n    this.next = (next===undefined ? null : next)\n}\n\nvar mergeTwoLists = function(l1, l2) {\n  const dummpy = node = new ListNode();\n  while(l1 && l2){\n      if(l1.val >= l2.val){\n          node.next = l2;\n          node = node.next;\n          l2 = l2.next;\n      } else {\n          node.next = l1;\n          node = node.next;\n          l1 = l1.next;\n      }\n  }\n  node.next = l1 || l2;\n  return dummpy.next;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_28-实现str"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28-实现str"}},[n._v("#")]),n._v(" 28. 实现str（）")]),n._v(" "),e("p",[n._v("题目如下：")]),n._v(" "),e("p",[n._v("实现 "),e("code",[n._v("strStr()")]),n._v(" 函数。")]),n._v(" "),e("p",[n._v("给你两个字符串 "),e("code",[n._v("haystack")]),n._v(" 和 "),e("code",[n._v("needle")]),n._v(" ，请你在 "),e("code",[n._v("haystack")]),n._v(" 字符串中找出 "),e("code",[n._v("needle")]),n._v(" 字符串出现的第一个位置（下标从 "),e("code",[n._v("0")]),n._v(" 开始）。如果不存在，则返回 "),e("code",[n._v("-1")]),n._v(" 。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例 1：\n\n输入：haystack = "hello", needle = "ll"\n输出：2\n示例 2：\n\n输入：haystack = "aaaaa", needle = "bba"\n输出：-1\n示例 3：\n\n输入：haystack = "", needle = ""\n输出：0\n \n\n提示：\n\n0 <= haystack.length, needle.length <= 5 * 104\nhaystack 和 needle 仅由小写英文字符组成\n复制代码\n')])])]),e("p",[n._v("思路：")]),n._v(" "),e("p",[n._v("本来这道题最佳算法是KMP，这个算法理解起来对我来说有难度，所以自己换了另一种思路")]),n._v(" "),e("ul",[e("li",[n._v("遍历字符串看是否有和需要找的字符串第一个字母相同")]),n._v(" "),e("li",[n._v("如果相同，就截取字符串跟需要找的字符串相同长度的字符串对比")]),n._v(" "),e("li",[n._v("相同就返回下标，不同就继续遍历原字符串")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('var strStr = function (haystack, needle) {\n  if (needle === "") return 0\n  for (var i = 0; i < haystack.length; i++) {\n      if (haystack[i] === needle[0]) {\n          if (haystack.substring(i, i + needle.length) === needle) return i;\n      }\n  }\n  return -1\n};\n复制代码\n')])])]),e("h2",{attrs:{id:"_118-杨辉三角"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_118-杨辉三角"}},[n._v("#")]),n._v(" 118. 杨辉三角")]),n._v(" "),e("p",[n._v("这个可是找规律的代表题，并且这道题可以训练一下你对"),e("code",[n._v("二维数组")]),n._v(" 转化为 "),e("code",[n._v("代码")]),n._v("的能力：")]),n._v(" "),e("p",[n._v("给定一个非负整数 "),e("em",[n._v("numRows，")]),n._v(" 生成杨辉三角的前 "),e("em",[n._v("numRows")]),n._v(" 行。")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("p",[n._v("在杨辉三角中，每个数是它左上方和右上方的数的和。")]),n._v(" "),e("p",[e("strong",[n._v("示例:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n复制代码\n")])])]),e("p",[n._v("思路：")]),n._v(" "),e("ul",[e("li",[n._v("看到上图可以发现，生成杨辉三角"),e("code",[n._v("numRows")]),n._v("行，数组就有"),e("code",[n._v("numRows")]),n._v("行")]),n._v(" "),e("li",[n._v("每一行，它的数组第一个位置和最后一个位置都是"),e("code",[n._v("1")])]),n._v(" "),e("li",[n._v("每一行，除了第一个和最后一个位置，其它位置的值"),e("code",[n._v("等于上一行的两个值相加")])])]),n._v(" "),e("p",[n._v("把思路翻译成代码即可：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var generate = function(numRows) {\n  if(numRows === 0){ return [] }\n  const result = Array.from(new Array(numRows), ()=>[])\n  for(let i = 0; i < numRows; i++){\n    result[i][0] = 1; result[i][i] = 1;\n      for(let j = 1; j < i; j++){\n      result[i][j] = result[i-1][j-1] + result[i-1][j] \n    }\n  }\nreturn result\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_121-买卖股票的最佳时机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_121-买卖股票的最佳时机"}},[n._v("#")]),n._v(" 121. 买卖股票的最佳时机")]),n._v(" "),e("p",[n._v("接下来这道题，你简单看下题目就行，解答原理超级简单，看图说话，找规律！")]),n._v(" "),e("p",[n._v("我们先看题：")]),n._v(" "),e("p",[n._v("给定一个数组 "),e("code",[n._v("prices")]),n._v(" ，它的第 "),e("code",[n._v("i")]),n._v(" 个元素 "),e("code",[n._v("prices[i]")]),n._v(" 表示一支给定股票第 "),e("code",[n._v("i")]),n._v(" 天的价格。")]),n._v(" "),e("p",[n._v("你只能选择 "),e("code",[n._v("某一天 买入这只股票，并选择在 未来的某一个不同的日子")]),n._v(" 卖出该股票。设计一个算法来计算你所能获取的最大利润。")]),n._v(" "),e("p",[n._v("返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n示例 2：\n\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n \n\n提示：\n\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n复制代码\n")])])]),e("p",[n._v("解题思路：我们先看一张图，假设给定的数组为："),e("code",[n._v("[7, 1, 5, 3, 6, 4]")])]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("ul",[e("li",[n._v("第一天是7，我们记录一下，因为还没到第二天不知道这个价格是高是低，"),e("code",[n._v("标记最小值是7")])]),n._v(" "),e("li",[n._v("第二天是1，"),e("code",[n._v("比7小")]),n._v("，那么只要当前天数的值比前面小，就说明不卖，因为它是最小值，"),e("code",[n._v("标记最小值是7")])]),n._v(" "),e("li",[n._v("第三天是5，5比前一天大，说明比最小值要大，那么可以卖，利润就是"),e("code",[n._v("5-1=4")])]),n._v(" "),e("li",[n._v("第四天发现是3，比5小，还是一样的道理，比之前小，最小值就要变为当前值，啥也不干，"),e("code",[n._v("标记最小值是3")])]),n._v(" "),e("li",[n._v("第五天发现是6...，第六天发现是4，规律是一样的")])]),n._v(" "),e("p",[n._v("意思是只要今天比昨天低，就可以用今天的减去最小值，就是利润，然后每次都比较这个利润是不是最大就行了")]),n._v(" "),e("p",[n._v("结合一下代码，就会清楚")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var maxProfit = function(prices) {\n  let res = 0;\n  let min = prices[0];\n  for(let i = 1; i < prices.length; i++){\n      if(prices[i] < min){\n          min = prices[i]\n      } else {\n          res = Math.max(res, prices[i] - min)\n      }   \n  }\n  return res;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_122-买卖股票的最佳时机2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_122-买卖股票的最佳时机2"}},[n._v("#")]),n._v(" 122. 买卖股票的最佳时机2")]),n._v(" "),e("p",[n._v("又来一道看图说话题目，简单！走起！")]),n._v(" "),e("p",[n._v("先看题目：")]),n._v(" "),e("p",[n._v("给定一个数组 "),e("code",[n._v("prices")]),n._v(" ，其中 "),e("code",[n._v("prices[i]")]),n._v(" 是一支给定股票第 "),e("code",[n._v("i")]),n._v(" 天的价格。")]),n._v(" "),e("p",[n._v("设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。")]),n._v(" "),e("p",[n._v("注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1:\n\n输入: prices = [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n示例 2:\n\n输入: prices = [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n示例 3:\n\n输入: prices = [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n复制代码\n")])])]),e("p",[n._v("思路，看图马上思路就出来了：")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("我们的利润就跟上图绿色部分显示的一样，也就是说只要今天减去昨天，是正数就是利润，简单吧，哈哈！")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var maxProfit = function(prices) {\n  let result = 0\n  for(let i = 1; i < prices.length; i++){\n      if(prices[i] > prices[i-1]){\n          result += prices[i] - prices[i - 1]\n      }\n  }\n  return result\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_206-反转链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_206-反转链表"}},[n._v("#")]),n._v(" 206. 反转链表")]),n._v(" "),e("p",[n._v("这个题必须掌握牢实，是解很多链接表题的基础的基础。先看题目：")]),n._v(" "),e("p",[n._v("给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。")]),n._v(" "),e("p",[n._v("示例 1：")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n复制代码\n")])])]),e("p",[n._v("示例 2：")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [1,2]\n输出：[2,1]\n复制代码\n")])])]),e("p",[n._v("解题思路依然是看图找规律，下图就是，我们把链表前面加一个null，这样翻转前和翻转后就一致了。"),e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("解答：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var reverseList = function(head) {\n  let [pre, node] = [null, head];\n  while(node){\n      const temp = node.next;\n      node.next = pre;\n      pre = node;\n      node = temp;\n  }\n  return pre;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"双指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双指针"}},[n._v("#")]),n._v(" 双指针")]),n._v(" "),e("p",[n._v("双指针是解数组类型题最常见解法")]),n._v(" "),e("ul",[e("li",[n._v("比如有头尾分别有指针，然后依次向中间靠拢的双指针，")]),n._v(" "),e("li",[n._v("还有一种是快慢是指针，两个指针都是从左边开始，一个走的快，一个走得慢")])]),n._v(" "),e("p",[n._v("具体的细节还是需要从题里体会，我们现在就开始！")]),n._v(" "),e("h2",{attrs:{id:"_26-删除数组中的重复项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-删除数组中的重复项"}},[n._v("#")]),n._v(" 26. 删除数组中的重复项")]),n._v(" "),e("p",[n._v("先看一下题目：")]),n._v(" "),e("p",[n._v("给你一个有序数组 "),e("code",[n._v("nums")]),n._v(" ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。")]),n._v(" "),e("p",[n._v("不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n \n\n提示：\n\n0 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums 已按升序排列\n复制代码\n")])])]),e("p",[n._v("初始状态是：")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("ul",[e("li",[n._v("慢指针是"),e("code",[n._v("i")]),n._v("，快指针是"),e("code",[n._v("j")])]),n._v(" "),e("li",[n._v("如果"),e("code",[n._v("nums[i]")]),n._v(" 等于 "),e("code",[n._v("nums[j]")]),n._v(" 说明是相同的元素，"),e("code",[n._v("j")]),n._v("继续走，"),e("code",[n._v("i")]),n._v("还在原位")]),n._v(" "),e("li",[n._v("如果"),e("code",[n._v("nums[i]")]),n._v(" 不等于 "),e("code",[n._v("nums[j]")]),n._v(" 说明是不相同的元素，那么"),e("code",[n._v("nums[i++] = nums[j]")]),n._v("，"),e("code",[n._v("j")]),n._v("继续向前走")])]),n._v(" "),e("p",[n._v("依次类推，就相当于"),e("code",[n._v("i")]),n._v("指针保证它和它前面的数字都是不重复的，"),e("code",[n._v("j")]),n._v("就是一个遍历器")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var removeDuplicates = function(nums) {\n  let i = 0;\n  for(let j = 1; j < nums.length; j++){\n      if(nums[j] !== nums[i]){\n          nums[i+1] = nums[j];\n          i++\n      }\n  }\n  return i + 1\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_88-合并两个有序数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_88-合并两个有序数组"}},[n._v("#")]),n._v(" 88. 合并两个有序数组")]),n._v(" "),e("p",[n._v("我们先看题目：")]),n._v(" "),e("p",[n._v("给你两个有序整数数组 "),e("code",[n._v("nums1")]),n._v(" 和 "),e("code",[n._v("nums2")]),n._v("，请你将 "),e("code",[n._v("nums2")]),n._v(" 合并到 "),e("code",[n._v("nums1")]),n._v(" 中，使 "),e("code",[n._v("nums1")]),n._v(" 成为一个有序数组。")]),n._v(" "),e("p",[n._v("初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n示例 2：\n\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n \n\n提示：\n\nnums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-109 <= nums1[i], nums2[i] <= 109\n复制代码\n")])])]),e("p",[n._v("这道题大家很容易想到，新创建一个数组，然后分别比较这两个数组里的每一项，push进去就行了")]),n._v(" "),e("p",[n._v("然而因为是有序数组，第一个数组还有正好满足假如第二数组的空间，所以这里可以采取双指针来解答，从后往前遍历")]),n._v(" "),e("p",[n._v("参考如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var merge = function (nums1, m, nums2, n) {\n  let len = m + n - 1;\n  m--, n--;\n  while (m >= 0 && n >= 0) {\n    if (nums1[m] > nums2[n]) {\n      nums1[len] = nums1[m--]\n    } else {\n      nums1[len] = nums2[n--]\n    }\n    len--;\n  }\n  if(m === -1){\n    return nums1.splice(0, len+1, ...nums2.slice(0, n + 1));\n  }\n  if(n === -1){\n    return nums1;\n  }\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_125-验证回文串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_125-验证回文串"}},[n._v("#")]),n._v(" 125. 验证回文串")]),n._v(" "),e("p",[n._v("请看题目：")]),n._v(" "),e("p",[n._v("给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。")]),n._v(" "),e("p",[n._v("说明：本题中，我们将空字符串定义为有效的回文串。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例 1:\n\n输入: "A man, a plan, a canal: Panama"\n输出: true\n解释："amanaplanacanalpanama" 是回文串\n示例 2:\n\n输入: "race a car"\n输出: false\n解释："raceacar" 不是回文串\n复制代码\n')])])]),e("p",[n._v("这个题太简单了，以至于不用写思路了，看代码就知道，就是用用双指针头尾向中间靠拢的解法，")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var isPalindrome = function(s) {\n  s = s.replace(/[^\\w]/g, '').toLowerCase();\n  let leftPointer = 0;\n  let rightPointer = s.length - 1;\n  while(rightPointer > leftPointer){\n      if(s[leftPointer++] === s[rightPointer--]){\n          continue;\n      }else{\n          return false;\n      }\n  }\n  return true;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_234-回文链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_234-回文链表"}},[n._v("#")]),n._v(" 234. 回文链表")]),n._v(" "),e("p",[n._v("这个题思路跟上面是一样的，都是双指针对比，但是主要这个题写起来很麻烦，要用到我们之前说的翻转链表，")]),n._v(" "),e("p",[n._v("解题思路：")]),n._v(" "),e("ul",[e("li",[n._v("先用快慢指针的手法，让我们知道这个链表的中点是哪，然后从中点截断")]),n._v(" "),e("li",[n._v("然后截断成为两个链表，把后面的链表翻转")]),n._v(" "),e("li",[n._v("最后依次去判断这两个链表每一项是否相同")])]),n._v(" "),e("p",[n._v("关键点：如何从中点截断这个链表,方法如下，让一个指针每次走一步，另一个指针每次走两步，这样他们每次走的倍数就相差2倍。代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  let fast = head;\n  let slow = head;\n  let prev;\n  while (fast && fast.next) {\n    prev = slow;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\nprev.next = null;  // 断成两个链表\n复制代码\n")])])]),e("ul",[e("li",[n._v("接着我们需要翻转链表")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" // 翻转后半段\n  let head2 = null;\n  while (slow) {\n    const tmp = slow.next;\n    slow.next = head2;\n    head2 = slow;\n    slow = tmp;\n  }\n复制代码\n")])])]),e("ul",[e("li",[n._v("最后对比就看下面具体代码了")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const isPalindrome = (head) => {\n  if (head == null || head.next == null) {\n    return true;\n  }\n  let fast = head;\n  let slow = head;\n  let prev;\n  while (fast && fast.next) {\n    prev = slow;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  prev.next = null;  // 断成两个链表\n  // 翻转后半段\n  let head2 = null;\n  while (slow) {\n    const tmp = slow.next;\n    slow.next = head2;\n    head2 = slow;\n    slow = tmp;\n  }\n  // 比对\n  while (head && head2) {\n    if (head.val != head2.val) {\n      return false;\n    }\n    head = head.next;\n    head2 = head2.next;\n  }\n  return true;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_237-删除链表中的节点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_237-删除链表中的节点"}},[n._v("#")]),n._v(" 237. 删除链表中的节点")]),n._v(" "),e("p",[n._v("题目如下：")]),n._v(" "),e("p",[n._v("请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。")]),n._v(" "),e("p",[n._v("现有一个链表 -- head = [4,5,1,9]，它可以表示为:")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("image.png")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n示例 2：\n\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n \n\n提示：\n\n链表至少包含两个节点。\n链表中所有节点的值都是唯一的。\n给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n不要从你的函数中返回任何结果。\n复制代码\n")])])]),e("p",[n._v("这个题很简单，其实这个node是个引用类型，你只需要把node的val变为node.next的val，然后node的next指向node.next.next，就移花接木，完成任务了！自己可以试着在草稿上画一下，结合代码很快就会明白！")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var deleteNode = function(node) {\n  node.val = node.next.val\n  node.next = node.next.next\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_283-移动零"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_283-移动零"}},[n._v("#")]),n._v(" 283. 移动零")]),n._v(" "),e("p",[n._v("题目如下：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组。\n尽量减少操作次数。\n复制代码\n")])])]),e("p",[n._v("如动画所示，我们可以用快慢指针来解答，具体不好用语言叙述，看动图")]),n._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),n._v("show")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var moveZeroes = function(nums) {\n  let i = j = 0;\n  while(i < nums.length) {\n      if(nums[i] !== 0){\n          [nums[i], nums[j]] = [nums[j], nums[i]]\n          j++\n      }\n      i++\n  }\n\n  return nums\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_344-反转字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_344-反转字符串"}},[n._v("#")]),n._v(" 344. 反转字符串")]),n._v(" "),e("p",[n._v("题目如下：")]),n._v(" "),e("p",[n._v("编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。")]),n._v(" "),e("p",[n._v("不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。")]),n._v(" "),e("p",[n._v("你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('示例 1：\n\n输入：["h","e","l","l","o"]\n输出：["o","l","l","e","h"]\n示例 2：\n\n输入：["H","a","n","n","a","h"]\n输出：["h","a","n","n","a","H"]\n复制代码\n')])])]),e("p",[n._v("这个题目实在太简单了，知道用首位双指针即可，看参考：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var reverseString = function(s) {\n  let l = 0 ;\n  let r = s.length - 1;\n  while(l < r){\n    [s[l], s[r]] = [s[r], s[l]];\n    l++; r--;\n  }\n  return s;\n};\n复制代码\n")])])]),e("h2",{attrs:{id:"_350-两个数组的交集ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_350-两个数组的交集ii"}},[n._v("#")]),n._v(" 350. 两个数组的交集II")]),n._v(" "),e("p",[n._v("题目如下：给定两个数组，编写一个函数来计算它们的交集。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("示例 1：\n\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2,2]\n示例 2:\n\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[4,9]\n\n说明：\n\n输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。\n我们可以不考虑输出结果的顺序。\n\n复制代码\n")])])]),e("p",[n._v("这个取交集需要保留重复元素，可以是用双指针来解答，具体思路和代码如下")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。")])]),n._v(" "),e("li",[e("p",[n._v("首先对两个数组进行排序，然后使用两个指针遍历两个数组。")])]),n._v(" "),e("li",[e("ul",[e("li",[n._v("初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束")])])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var intersect = function(nums1, nums2) {\n  nums1 = nums1.sort((a, b) => a - b);\n  nums2 = nums2.sort((a, b) => a - b);\n  let l1 = 0;\n  let l2 = 0;\n  const nums1Len = nums1.length;\n  const nums2Len = nums2.length;\n  const ret = [];\n  while(l1 < nums1Len && l2 < nums2Len){\n    if(nums1[l1] === nums2[l2]){\n      ret.push(nums1[l1]);\n      l1++;\n      l2++;\n    }\n    if(nums1[l1] > nums2[l2]) l2++;\n    if(nums1[l1] < nums2[l2]) l1++;\n  }\n  return ret;\n};\n复制代码\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);