(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{402:function(e,n,t){"use strict";t.r(n);var a=t(4),v=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"说说react-render方法的原理-在什么时候会被触发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#说说react-render方法的原理-在什么时候会被触发"}},[e._v("#")]),e._v(" 说说React render方法的原理？在什么时候会被触发？")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibTf1ZtJbBmic3eTiaBCHK4FgMicfBdEOvdpDrcpQScq9iaWoQofCUpcDatfTyt0Xia86CpyPSwcCslk7vw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("h2",{attrs:{id:"一、原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、原理"}},[e._v("#")]),e._v(" 一、原理")]),e._v(" "),n("p",[e._v("首先，"),n("code",[e._v("render")]),e._v("函数在"),n("code",[e._v("react")]),e._v("中有两种形式：")]),e._v(" "),n("p",[e._v("在类组件中，指的是"),n("code",[e._v("render")]),e._v("方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Foo extends React.Component {\n    render() {\n        return <h1> Foo </h1>;\n    }\n}\n")])])]),n("p",[e._v("在函数组件中，指的是函数组件本身：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Foo() {\n    return <h1> Foo </h1>;\n}\n")])])]),n("p",[e._v("在"),n("code",[e._v("render")]),e._v("中，我们会编写"),n("code",[e._v("jsx")]),e._v("，"),n("code",[e._v("jsx")]),e._v("通过"),n("code",[e._v("babel")]),e._v("编译后就会转化成我们熟悉的"),n("code",[e._v("js")]),e._v("格式，如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("return (\n  <div className='cn'>\n    <Header> hello </Header>\n    <div> start </div>\n    Right Reserve\n  </div>\n)\n")])])]),n("p",[n("code",[e._v("babel")]),e._v("编译后：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("return (\n  React.createElement(\n    'div',\n    {\n      className : 'cn'\n    },\n    React.createElement(\n      Header,\n      null,\n      'hello'\n    ),\n    React.createElement(\n      'div',\n      null,\n      'start'\n    ),\n    'Right Reserve'\n  )\n)\n")])])]),n("p",[e._v("从名字上来看，"),n("code",[e._v("createElement")]),e._v("方法用来元素的")]),e._v(" "),n("p",[e._v("在"),n("code",[e._v("react")]),e._v("中，这个元素就是虚拟"),n("code",[e._v("DOM")]),e._v("树的节点，接收三个参数：")]),e._v(" "),n("ul",[n("li",[e._v("type：标签")]),e._v(" "),n("li",[e._v("attributes：标签属性，若无则为null")]),e._v(" "),n("li",[e._v("children：标签的子节点")])]),e._v(" "),n("p",[e._v("这些虚拟"),n("code",[e._v("DOM")]),e._v("树最终会渲染成真实"),n("code",[e._v("DOM")])]),e._v(" "),n("p",[e._v("在"),n("code",[e._v("render")]),e._v("过程中，"),n("code",[e._v("React")]),e._v(" 将新调用的 "),n("code",[e._v("render")]),e._v("函数返回的树与旧版本的树进行比较，这一步是决定如何更新 "),n("code",[e._v("DOM")]),e._v(" 的必要步骤，然后进行 "),n("code",[e._v("diff")]),e._v(" 比较，更新 "),n("code",[e._v("DOM")]),e._v("树")]),e._v(" "),n("h2",{attrs:{id:"二、触发时机"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、触发时机"}},[e._v("#")]),e._v(" 二、触发时机")]),e._v(" "),n("p",[n("code",[e._v("render")]),e._v("的执行时机主要分成了两部分：")]),e._v(" "),n("ul",[n("li",[e._v("类组件调用 setState 修改状态")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class Foo extends React.Component {\n  state = { count: 0 };\n\n  increment = () => {\n    const { count } = this.state;\n\n    const newCount = count < 10 ? count + 1 : count;\n\n    this.setState({ count: newCount });\n  };\n\n  render() {\n    const { count } = this.state;\n    console.log("Foo render");\n\n    return (\n      <div>\n        <h1> {count} </h1>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n')])])]),n("p",[e._v("点击按钮，则调用"),n("code",[e._v("setState")]),e._v("方法，无论"),n("code",[e._v("count")]),e._v("发生变化与否，控制台都会输出"),n("code",[e._v("Foo render")]),e._v("，证明"),n("code",[e._v("render")]),e._v("执行了")]),e._v(" "),n("ul",[n("li",[e._v("函数组件通过"),n("code",[e._v("useState hook")]),e._v("修改状态")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function Foo() {\n  const [count, setCount] = useState(0);\n\n  function increment() {\n    const newCount = count < 10 ? count + 1 : count;\n    setCount(newCount);\n  }\n\n  console.log("Foo render");\n  \n  return (\n    <div>\n      <h1> {count} </h1>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n')])])]),n("p",[e._v("函数组件通过"),n("code",[e._v("useState")]),e._v("这种形式更新数据，当数组的值不发生改变了，就不会触发"),n("code",[e._v("render")])]),e._v(" "),n("ul",[n("li",[e._v("类组件重新渲染")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('class App extends React.Component {\n  state = { name: "App" };\n  render() {\n    return (\n      <div className="App">\n        <Foo />\n        <button onClick={() => this.setState({ name: "App" })}>\n          Change name\n        </button>\n      </div>\n    );\n  }\n}\n\nfunction Foo() {\n  console.log("Foo render");\n\n  return (\n    <div>\n      <h1> Foo </h1>\n    </div>\n  );\n}\n')])])]),n("p",[e._v("只要点击了 "),n("code",[e._v("App")]),e._v(" 组件内的 "),n("code",[e._v("Change name")]),e._v(" 按钮，不管 "),n("code",[e._v("Foo")]),e._v(" 具体实现是什么，都会被重新"),n("code",[e._v("render")]),e._v("渲染")]),e._v(" "),n("ul",[n("li",[e._v("函数组件重新渲染")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function App(){\n    const [name,setName] = useState(\'App\')\n\n    return (\n        <div className="App">\n            <Foo />\n            <button onClick={() => setName("aaa")}>\n                { name }\n            </button>\n      </div>\n    )\n}\n\nfunction Foo() {\n  console.log("Foo render");\n\n  return (\n    <div>\n      <h1> Foo </h1>\n    </div>\n  );\n}\n')])])]),n("p",[e._v("可以发现，使用"),n("code",[e._v("useState")]),e._v("来更新状态的时候，只有首次会触发"),n("code",[e._v("Foo render")]),e._v("，后面并不会导致"),n("code",[e._v("Foo render")])]),e._v(" "),n("h2",{attrs:{id:"三、总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、总结"}},[e._v("#")]),e._v(" 三、总结")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("render`函数里面可以编写`JSX`，转化成`createElement`这种形式，用于生成虚拟`DOM`，最终转化成真实`DOM\n")])])]),n("p",[e._v("在"),n("code",[e._v("React")]),e._v(" 中，类组件只要执行了 "),n("code",[e._v("setState")]),e._v(" 方法，就一定会触发 "),n("code",[e._v("render")]),e._v(" 函数执行，函数组件使用"),n("code",[e._v("useState")]),e._v("更改状态不一定导致重新"),n("code",[e._v("render")])]),e._v(" "),n("p",[e._v("组件的"),n("code",[e._v("props")]),e._v(" 改变了，不一定触发 "),n("code",[e._v("render")]),e._v(" 函数的执行，但是如果 "),n("code",[e._v("props")]),e._v(" 的值来自于父组件或者祖先组件的 "),n("code",[e._v("state")])]),e._v(" "),n("p",[e._v("在这种情况下，父组件或者祖先组件的 "),n("code",[e._v("state")]),e._v(" 发生了改变，就会导致子组件的重新渲染")]),e._v(" "),n("p",[e._v("所以，一旦执行了"),n("code",[e._v("setState")]),e._v("就会执行"),n("code",[e._v("render")]),e._v("方法，"),n("code",[e._v("useState")]),e._v(" 会判断当前值有无发生改变确定是否执行"),n("code",[e._v("render")]),e._v("方法，一旦父组件发生渲染，子组件也会渲染")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("h2",{attrs:{id:"参考文献"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[e._v("#")]),e._v(" 参考文献")]),e._v(" "),n("ul",[n("li",[e._v("https://zhuanlan.zhihu.com/p/45091185")]),e._v(" "),n("li",[e._v("https://juejin.cn/post/684490418149341595")])])])}),[],!1,null,null,null);n.default=v.exports}}]);