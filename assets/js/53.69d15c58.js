(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{346:function(t,a,s){"use strict";s.r(a);var e=s(4),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"慎用json-stringify"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慎用json-stringify"}},[t._v("#")]),t._v(" 慎用JSON.stringify")]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("项目中遇到一个 bug，一个组件为了保留一份 JSON 对象，使用 JSON.stringify 将其转换成字符串，这样做当然是为了避免对象是引用类型造成数据源的污染。")]),t._v(" "),a("p",[t._v("但发现后面使用 JSON.parse 方法之后，发现数据有所变化。")]),t._v(" "),a("p",[t._v("代码简化：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Gopal'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("age")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("Infinity")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" originObj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("originObj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// {"name":"Gopal","age":null}')]),t._v("\n")])])]),a("p",[t._v("可以看到，Infinity 变成了 null，从而导致了后面的 bug。其实项目中自己踩 JSON.stringify 的坑已经很多了，借此机会好好整理一下，也给大家一个参考")]),t._v(" "),a("p",[t._v("解决方法1：")]),t._v(" "),a("p",[t._v("简单粗暴，重新给 age 属性赋值")]),t._v(" "),a("p",[t._v("解决方法2：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("censor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("Infinity")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Infinity'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" censor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Infinity'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("Infinity")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这就有点绕了，当做参考吧，其实我自己是直接使用了第一种方法。不过这里可以看到 JSON.stringify 实际上还有第二个参数，那它有什么用呢？接下来我们揭开它的神秘面纱。")]),t._v(" "),a("h2",{attrs:{id:"json-stringify-基础语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify-基础语法"}},[t._v("#")]),t._v(" JSON.stringify 基础语法")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" replacer "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" space"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),a("p",[t._v("MDN 中文文档对它的解释如下：")]),t._v(" "),a("blockquote",[a("p",[t._v("JSON.stringify() 方法将一个 JavaScript 值**（对象或者数组）**转换为一个 JSON 字符串，如果指定了 replacer 是一个函数，则可以选择性地替换值，或者如果指定了 replacer 是一个数组，则可选择性地仅包含数组指定的属性。")])]),t._v(" "),a("p",[t._v("我个人觉得是有所不妥的，不妥之处在于“对象或者数组”，因为实际上对于普通的值，我们也可以使用 JSON.stringify，只是我们很少这么用罢了。不过这个问题不大，我们文中介绍的也都是针对对象或者数组。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("JSON.stringify('foo');   // '\"foo\"'\n")])])]),a("p",[t._v("英文版的解释就会合理很多")]),t._v(" "),a("blockquote",[a("p",[t._v("The JSON.stringify() method converts a JavaScript object or value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.")])]),t._v(" "),a("p",[t._v("简单来说，JSON.stringify() 就是将值转换为相应的 JSON 格式字符串。")]),t._v(" "),a("h3",{attrs:{id:"json-stringify-强大的第二个参数-replacer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify-强大的第二个参数-replacer"}},[t._v("#")]),t._v(" JSON.stringify 强大的第二个参数 replacer")]),t._v(" "),a("p",[t._v("这个参数是可选的，可以是一个函数，也可以是一个数组")]),t._v(" "),a("p",[t._v("当是一个函数的时候，则在序列化的过程中，被序列化的每个属性都会经过该函数的转换和处理，看如下代码：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let replacerFun = function (key, value) {  console.log(key, value)  if (key === 'name') {    return undefined  }  return value}\nlet myIntro = {  name: 'Gopal',  age: 25,  like: 'FE'}\nconsole.log(JSON.stringify(myIntro, replacerFun))// {\"age\":25,\"like\":\"FE\"}\n")])])]),a("p",[t._v("这里其实就是一个筛选的作用，利用的是 JSON.stringify 中对象属性值为 undefined 就会在序列化中被忽略的特性（后面我们会提到）")]),t._v(" "),a("p",[t._v("值得注意的是，在一开始 replacer 函数会被传入一个空字符串作为 key 值，代表着要被 stringify 的这个对象")]),t._v(" "),a("p",[t._v("上面 console.log(key, value) 输出的值如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' { name: \'Gopal\', age: 25, like: \'FE\' }name Gopalage 25like FE{"age":25,"like":"FE"}\n')])])]),a("p",[t._v("可以看出，通过第二个参数，我们可以更加灵活的去操作和修改被序列化目标的值")]),t._v(" "),a("p",[t._v("当第二个参数为数组的时候，只有包含在这个数组中的属性名才会被序列化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('JSON.stringify(myIntro, [\'name\']) // {"name":"Gopal"}\n')])])]),a("h3",{attrs:{id:"中看不中用的第三个参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中看不中用的第三个参数"}},[t._v("#")]),t._v(" 中看不中用的第三个参数")]),t._v(" "),a("p",[t._v("指定缩进用的空白字符串，更多时候就是指定一个数字，代表几个空格：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let myIntro = {  name: \'Gopal\',  age: 25,  like: \'FE\'}\nconsole.log(JSON.stringify(myIntro))console.log(JSON.stringify(myIntro, null, 2))\n// {"name":"Gopal","age":25,"like":"FE"}// {//   "name": "Gopal",//   "age": 25,//   "like": "FE"// }\n')])])]),a("h2",{attrs:{id:"json-stringify-使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify-使用场景"}},[t._v("#")]),t._v(" JSON.stringify 使用场景")]),t._v(" "),a("h3",{attrs:{id:"判断对象-数组值是否相等"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断对象-数组值是否相等"}},[t._v("#")]),t._v(" 判断对象/数组值是否相等")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a = [1,2,3],    b = [1,2,3];JSON.stringify(a) === JSON.stringify(b);// true\n")])])]),a("h3",{attrs:{id:"localstorage-sessionstorage-存储对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-sessionstorage-存储对象"}},[t._v("#")]),t._v(" localStorage/sessionStorage 存储对象")]),t._v(" "),a("p",[t._v("我们知道 localStorage/sessionStorage 只可以存储字符串，当我们想存储对象的时候，需要使用 JSON.stringify 转换成字符串，获取的时候再 JSON.parse")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 存function setLocalStorage(key,val) {    window.localStorage.setItem(key, JSON.stringify(val));};// 取function getLocalStorage(key) {    let val = JSON.parse(window.localStorage.getItem(key));    return val;};\n")])])]),a("h3",{attrs:{id:"实现对象深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现对象深拷贝"}},[t._v("#")]),t._v(" 实现对象深拷贝")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let myIntro = {  name: 'Gopal',  age: 25,  like: 'FE'}\nfunction deepClone() {  return JSON.parse(JSON.stringify(myIntro))}\nlet copyMe = deepClone(myIntro)copyMe.like = 'Fitness'console.log(myIntro, copyMe)\n// { name: 'Gopal', age: 25, like: 'FE' } { name: 'Gopal', age: 25, like: 'Fitness' }\n")])])]),a("h3",{attrs:{id:"路由-浏览器地址-传参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由-浏览器地址-传参"}},[t._v("#")]),t._v(" 路由（浏览器地址）传参")]),t._v(" "),a("p",[t._v("因为浏览器传参只能通过字符串进行，所以也是需要用到 JSON.stringify")]),t._v(" "),a("h2",{attrs:{id:"json-stringify-使用注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#json-stringify-使用注意事项"}},[t._v("#")]),t._v(" JSON.stringify 使用注意事项")]),t._v(" "),a("p",[t._v("看了上面，是不是觉得 JSON.stringify 功能很强大，立马想在项目中尝试了呢？稍等稍等，先看完以下的注意事项再做决定吧，可能在某些场景下会触发一些难以发现的问题")]),t._v(" "),a("h3",{attrs:{id:"转换属性值中有-tojson-方法-慎用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换属性值中有-tojson-方法-慎用"}},[t._v("#")]),t._v(" 转换属性值中有 toJSON 方法，慎用")]),t._v(" "),a("p",[t._v("转换值中如果有 toJSON 方法，该方法返回的值将会是最后的序列化结果")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// toJSONlet toJsonMyIntro = {  name: "Gopal",  age: 25,  like: "FE",  toJSON: function () {    return "前端杂货铺";  },};\nconsole.log(JSON.stringify(toJsonMyIntro)); // "前端杂货铺"\n')])])]),a("h3",{attrs:{id:"被转换值中有-undefined、任意的函数以及-symbol-值-慎用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#被转换值中有-undefined、任意的函数以及-symbol-值-慎用"}},[t._v("#")]),t._v(" 被转换值中有 undefined、任意的函数以及 symbol 值，慎用")]),t._v(" "),a("p",[t._v("分为两种情况")]),t._v(" "),a("p",[t._v("一种是数组对象，undefined、任意的函数以及 symbol 值会被转换成 null")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("JSON.stringify([undefined, Object, Symbol(\"\")]);// '[null,null,null]'\n")])])]),a("p",[t._v("一种是非数组对象，在序列化的过程中会被忽略")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("JSON.stringify({ x: undefined, y: Object, z: Symbol(\"\") });// '{}'\n")])])]),a("p",[t._v("对于这种情况，我们可以使用 JSON.stringify 的第二个参数，使其达到符合我们的预期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const testObj = { x: undefined, y: Object, z: Symbol("test") }\nconst resut = JSON.stringify(testObj, function (key, value) {  if (value === undefined) {    return \'undefined\'  } else if (typeof value === "symbol" || typeof value === "function") {    return value.toString()  }  return value})\nconsole.log(resut)// {"x":"undefined","y":"function Object() { [native code] }","z":"Symbol(test)"}\n')])])]),a("h3",{attrs:{id:"包含循环引用的对象-慎用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包含循环引用的对象-慎用"}},[t._v("#")]),t._v(" 包含循环引用的对象，慎用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let objA = {  name: "Gopal",}\nlet objB = {  age: 25,}\nobjA.age = objBobjB.name = objAJSON.stringify(objA)\n')])])]),a("p",[t._v("会报以下错误：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Uncaught TypeError: Converting circular structure to JSON    --\x3e starting at object with constructor 'Object'    |     property 'age' -> object with constructor 'Object'    --- property 'name' closes the circle    at JSON.stringify (<anonymous>)    at <anonymous>:1:6\n")])])]),a("h3",{attrs:{id:"以-symbol-为属性键的属性-慎用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#以-symbol-为属性键的属性-慎用"}},[t._v("#")]),t._v(" 以 symbol 为属性键的属性，慎用")]),t._v(" "),a("p",[t._v("所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")])// \'{}\'\nJSON.stringify({ [Symbol.for("foo")]: "foo" }, function (k, v) {  if (typeof k === "symbol") {    return "a symbol";  }})// undefined\n')])])]),a("h3",{attrs:{id:"值为-nan-和-infinity-慎用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#值为-nan-和-infinity-慎用"}},[t._v("#")]),t._v(" 值为 NaN 和 Infinity，慎用")]),t._v(" "),a("p",[t._v("数组的值，或者非数组对象属性值为 NaN 和 Infinity 的，会被转换成 null")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let me = {  name: "Gopal",  age: Infinity,  money: NaN,};let originObj = JSON.stringify(me);console.log(originObj); // {"name":"Gopal","age":null,"money":null}\nJSON.stringify([NaN, Infinity])// [null,null]\n')])])]),a("h3",{attrs:{id:"具有不可枚举的属性值时-慎用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具有不可枚举的属性值时-慎用"}},[t._v("#")]),t._v(" 具有不可枚举的属性值时，慎用")]),t._v(" "),a("p",[t._v("不可枚举的属性默认会被忽略：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let person = Object.create(null, {  name: { value: "Gopal", enumerable: false },  age: { value: "25", enumerable: true },})\nconsole.log(JSON.stringify(person))// {"age":"25"}\n')])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("JSON.stringify 在实际应用中确实很方便的解决了我们很多问题，比如简单的深拷贝等。但是我们在使用时候，也需要知道它有哪些不足之处，在目标值如果是一些特殊值的情况下，可能序列化后的结果会不符合我们的预期，这个时候就需要慎用")])])}),[],!1,null,null,null);a.default=n.exports}}]);