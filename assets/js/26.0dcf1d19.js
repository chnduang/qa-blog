(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{318:function(t,n,a){"use strict";a.r(n);var e=a(4),s=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"leetcode-最常见的150道前端面试题-简单题下"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#leetcode-最常见的150道前端面试题-简单题下"}},[t._v("#")]),t._v(" leetcode 最常见的150道前端面试题（简单题下）")]),t._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/kofbFk64Ghv7UDLgF81UMQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/kofbFk64Ghv7UDLgF81UMQ"),n("OutboundLink")],1)])]),t._v(" "),n("h2",{attrs:{id:"二叉树-dfs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树-dfs"}},[t._v("#")]),t._v(" 二叉树（DFS）")]),t._v(" "),n("h2",{attrs:{id:"二叉树前中后遍历套路详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树前中后遍历套路详解"}},[t._v("#")]),t._v(" 二叉树前中后遍历套路详解")]),t._v(" "),n("p",[t._v("前序遍历题目如下：")]),t._v(" "),n("p",[t._v("root节点是A节点（下图的A节点），然后让你按照下图数字的顺序依次打印出节点。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHooHWKWZD3tqVwTb3gxLebJaahnAwPDo7aSJTbN1P8ia8Y9K8vSia8gYvviaz3yJ9b3vwibWgxlWcPU3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t._v("d7948dc5e50e70cc84cfbd0e0cf989da40eb96167f03b710392be45b8c415662.png")]),t._v(" "),n("p",[t._v("我们可以看到这其中的规律，就是"),n("code",[t._v("深度优先遍历，先遍历左子树，再遍历右子树")]),t._v("，这里我们不用递归，因为一些大厂严格要求二叉树遍历不用递归，递归太简单了。")]),t._v(" "),n("p",[t._v("重点思路就是："),n("code",[t._v("深度优先遍历，先遍历左子树，再遍历右子树")]),t._v("，")]),t._v(" "),n("p",[t._v("所以，我们需要一套如何遍历一颗二叉树，并且是先左子树，再右子树的通用模板，如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var Traversal = function(root) {\n    const stack = [];\n    while (root || stack.length){\n      while(root){\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      root = root.right;\n    }\n    return res;\n};\n复制代码\n")])])]),n("p",[t._v("我们结合图片发现这个遍历产生的整体压栈的顺序是")]),t._v(" "),n("ul",[n("li",[t._v("A、B、D入栈，")]),t._v(" "),n("li",[t._v("D出栈")]),t._v(" "),n("li",[t._v("B出栈")]),t._v(" "),n("li",[t._v("E入栈")]),t._v(" "),n("li",[t._v("E出栈")]),t._v(" "),n("li",[t._v("A出栈")]),t._v(" "),n("li",[t._v("C入栈")]),t._v(" "),n("li",[t._v("C出栈")]),t._v(" "),n("li",[t._v("F入栈")]),t._v(" "),n("li",[t._v("F出栈")])]),t._v(" "),n("p",[t._v("我们把上面入栈的元素按顺序排列一下就是，A、B、D、E、C、F，而这就是前序遍历的顺序！解答完毕！")]),t._v(" "),n("p",[t._v("是不是很有意思，下面的中序遍历，我们看看出栈顺序是不是中序遍历的要求：D、B、E、A、C、F（这就是中序遍历的要求，好了，两个题解决）")]),t._v(" "),n("p",[t._v("放具体前序遍历代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var preorderTraversal = function(root) {\n    // 初始化数据\n    const res =[];\n    const stack = [];\n    while (root || stack.length){\n      while(root){\n        res.push(root.val);\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      root = root.right;\n    }\n    return res;\n};\n复制代码\n")])])]),n("p",[t._v("中序遍历是一个意思，在前序遍历的基础上改造一下"),n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHooHWKWZD3tqVwTb3gxLebJPK3LChu8L4VzEiccQtRz8Ay5pngbv3EP8Q95CiaDpBGUIrlf1FnY6zKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var preorderTraversal = function(root) {\n    // 初始化数据\n    const res =[];\n    const stack = [];\n    while (root || stack.length){\n      while(root){\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      res.push(root.val);\n      root = root.right;\n    }\n    return res;\n};\n复制代码\n")])])]),n("p",[t._v("后序遍历有点不太一样，但是套路是一样的，我们需要先遍历右子树，再遍历左子树，反着来，就可以了，代码如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHooHWKWZD3tqVwTb3gxLebJyEPmvILrdMDZvgEUSoNQgOKJe6G2sowzzs2CDCqIPeyN3aFvuZuFCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var postorderTraversal = function(root) {\n  // 初始化数据\n    const res =[];\n    const stack = [];\n    while (root || stack.length){\n      while(root){\n        stack.push(root);\n        res.unshift(root.val);\n        root = root.right;\n      }\n      root = stack.pop();\n      root = root.left;\n    }\n    return res;\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"对称二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对称二叉树"}},[t._v("#")]),t._v(" 对称二叉树")]),t._v(" "),n("p",[t._v("这个题简而言之就是判断一个二叉树是对称的，比如说：")]),t._v(" "),n("p",[t._v("二叉树 [1,2,2,3,4,4,3] 是对称的。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n复制代码\n")])])]),n("p",[t._v("但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n复制代码\n")])])]),n("p",[t._v("思路：")]),t._v(" "),n("p",[t._v("递归解决：")]),t._v(" "),n("ul",[n("li",[t._v("判断两个指针当前节点值是否相等")]),t._v(" "),n("li",[t._v("判断 "),n("code",[t._v("A")]),t._v(" 的右子树与 "),n("code",[t._v("B")]),t._v(" 的左子树是否对称")]),t._v(" "),n("li",[t._v("判断 "),n("code",[t._v("A")]),t._v(" 的左子树与 "),n("code",[t._v("B")]),t._v(" 的右子树是否对称")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function isSame(leftNode, rightNode){\n    if(leftNode === null && rightNode === null) return true;\n    if(leftNode === null || rightNode === null) return false;\n    return leftNode.val === rightNode.val && isSame(leftNode.left, rightNode.right) && isSame(leftNode.right, rightNode.left)\n}\nvar isSymmetric = function(root) {\n    if(!root) return root;\n    return isSame(root.left, root.right);\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"二叉树的最大深度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最大深度"}},[t._v("#")]),t._v(" 二叉树的最大深度")]),t._v(" "),n("p",[t._v("这个题在面试滴滴的时候遇到过，主要是掌握二叉树遍历的套路")]),t._v(" "),n("ul",[n("li",[t._v("只要遍历到这个节点既没有左子树，又没有右子树的时候")]),t._v(" "),n("li",[t._v("说明就到底部了，这个时候如果之前记录了深度，就可以比较是否比之前记录的深度大，大就更新深度")]),t._v(" "),n("li",[t._v("然后以此类推，一直比较到深度最大的")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var maxDepth = function(root) {\n    if(!root) return root;\n    let ret = 1;\n    function dfs(root, depth){\n        if(!root.left && !root.right) ret = Math.max(ret, depth);\n        if(root.left) dfs(root.left, depth+1);\n        if(root.right) dfs(root.right, depth+1);\n    }\n    dfs(root, ret);\n    return ret\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"将有序数组转化为二叉搜索树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将有序数组转化为二叉搜索树"}},[t._v("#")]),t._v(" 将有序数组转化为二叉搜索树")]),t._v(" "),n("p",[t._v("我们先看题：")]),t._v(" "),n("p",[t._v("给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。")]),t._v(" "),n("p",[t._v("高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。")]),t._v(" "),n("p",[t._v("示例 1：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHooHWKWZD3tqVwTb3gxLebJtNwcKdCOBUHn2libibvOkJrBicsDicLcDdxtW4hd6eZJnQfkCSmp9MMEgQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：nums = [-10,-3,0,5,9]\n输出：[0,-3,9,-10,null,5]\n解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n复制代码\n")])])]),n("p",[t._v("示例 2：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/H8M5QJDxMHooHWKWZD3tqVwTb3gxLebJWJboRJkqIIomVwSICFicL72WwnVjQzicwvrOlY0EfWiaWC8SkVHz8xXSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：nums = [1,3]\n输出：[3,1]\n解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。\n \n\n提示：\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums 按 严格递增 顺序排列\n复制代码\n")])])]),n("p",[t._v("思路：")]),t._v(" "),n("ul",[n("li",[t._v("构建一颗树包括：构建"),n("code",[t._v("root、构建 root.left 和 root.right")])]),t._v(" "),n("li",[t._v('题目要求"高度平衡" — 构建 '),n("code",[t._v("root")]),t._v(" 时候，选择数组的中间元素作为 "),n("code",[t._v("root")]),t._v(" 节点值，即可保持平衡。")]),t._v(" "),n("li",[t._v("递归函数可以传递数组，也可以传递指针，选择传递指针的时候：l r 分别代表参与构建BST的数组的首尾索引。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var sortedArrayToBST = function(nums) {\n    return toBST(nums, 0, nums.length - 1)\n};\nconst toBST = function(nums, l, r){\n    if( l > r){\n        return null;\n    }\n    const mid = l + r >> 1;\n    const root = new TreeNode(nums[mid]);\n    root.left = toBST(nums, l, mid - 1);\n    root.right = toBST(nums, mid + 1, r);\n\n    return root;\n}\n复制代码\n")])])]),n("h3",{attrs:{id:"栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),n("p",[t._v("栈是一种先进先出的数据结构，所以涉及到你需要"),n("code",[t._v("先进先出")]),t._v("这个想法后，就可以使用栈。")]),t._v(" "),n("p",[t._v("其次我觉得栈跟递归很相似，递归是不是先压栈，然后先进来的先出去，就跟函数调用栈一样。")]),t._v(" "),n("h2",{attrs:{id:"_20-有效的括号"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_20-有效的括号"}},[t._v("#")]),t._v(" 20. 有效的括号")]),t._v(" "),n("p",[t._v("这是一道很典型的用栈解决的问题， 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。")]),t._v(" "),n("p",[t._v("有效字符串需满足：")]),t._v(" "),n("p",[t._v("左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('示例 1：\n\n输入：s = "()"\n输出：true\n示例 2：\n\n输入：s = "()[]{}"\n输出：true\n示例 3：\n\n输入：s = "(]"\n输出：false\n示例 4：\n\n输入：s = "([)]"\n输出：false\n复制代码\n')])])]),n("p",[t._v("思路：这道题有一规律：")]),t._v(" "),n("ol",[n("li",[t._v("右括号前面，必须是相对应的左括号，才能抵消！")]),t._v(" "),n("li",[t._v("右括号前面，不是对应的左括号，那么该字符串，一定不是有效的括号！")])]),t._v(" "),n("p",[t._v("也就是说左括号我们直接放入栈中即可，发现是右括号就要对比是否跟栈顶元素相匹配，不匹配就返回false")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var isValid = function(s) {\n    const map = { '{': '}', '(': ')', '[': ']' };\n    const stack = [];\n    for(let i of s){\n        if(map[i]){\n            stack.push(i);\n        } else {\n            if(map[stack[stack.length - 1]] === i){\n                stack.pop()\n            }else{\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_155、-最小栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_155、-最小栈"}},[t._v("#")]),t._v(" 155、 最小栈")]),t._v(" "),n("p",[t._v("先看题目：")]),t._v(" "),n("p",[t._v("设计一个支持 "),n("code",[t._v("push ，pop ，top")]),t._v(" 操作，并能在常数时间内检索到最小元素的栈。")]),t._v(" "),n("ul",[n("li",[t._v("push(x) —— 将元素 x 推入栈中。")]),t._v(" "),n("li",[t._v("pop() —— 删除栈顶的元素。")]),t._v(" "),n("li",[t._v("top() —— 获取栈顶元素。")]),t._v(" "),n("li",[t._v("getMin() —— 检索栈中的最小元素。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例:\n\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.getMin();   --\x3e 返回 -2.\n\n提示：\n\npop、top 和 getMin 操作总是在 非空栈 上调用。\n复制代码\n")])])]),n("p",[t._v("我们先不写getMin方法，满足其他方法实现就非常简单，我们来看一下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var MinStack = function() {\n    this.stack = [];\n};\n\nMinStack.prototype.push = function(x) {\n    this.stack.push(x);\n};\n\nMinStack.prototype.pop = function() {\n    this.stack.pop();\n};\n\nMinStack.prototype.top = function() {\n    return this.stack[this.stack.length - 1];\n};\n复制代码\n")])])]),n("p",[t._v("如何保证每次取最小呢，我们举一个例子："),n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("p",[t._v("如上图，我们需要一个辅助栈来记录最小值，")]),t._v(" "),n("ul",[n("li",[t._v("开始我们向stack push -2")]),t._v(" "),n("li",[t._v("此时辅助栈minStack，因为此时stack最小的是-2，也push -2")]),t._v(" "),n("li",[t._v("stack push 0")]),t._v(" "),n("li",[t._v("此时辅助站minStack 会用 0 跟 -2对比，-2更小，minstack会push -2")]),t._v(" "),n("li",[t._v("stack push -3")]),t._v(" "),n("li",[t._v("此时辅助站minStack 会用 -3 跟 -2对比，-3更小，minstack会push -3")])]),t._v(" "),n("p",[t._v("所以我们取最小的时候，总能在minStack中取到最小值，所以解法就出来了：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var MinStack = function() {\n    this.stack = [];\n    // 辅助栈\n    this.minStack = [];\n};\n\nMinStack.prototype.push = function(x) {\n    this.stack.push(x);\n    // 如果是第一次或者当前x比最小栈里的最小值还小才push x\n    if(this.minStack.length === 0 || x < this.minStack[this.minStack.length - 1]){\n        this.minStack.push(x)\n    } else {\n         this.minStack.push( this.minStack[this.minStack.length - 1])\n    }\n};\n\nMinStack.prototype.pop = function() {\n    this.stack.pop();\n    this.minStack.pop();\n};\n\nMinStack.prototype.top = function() {\n    return this.stack[this.stack.length - 1];\n};\n\nMinStack.prototype.getMin = function() {\n    return this.minStack[this.stack.length - 1];\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"动态规划"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[t._v("#")]),t._v(" 动态规划")]),t._v(" "),n("p",[t._v("动态规划，一定要知道动态转移方程，有了这个，就相当于解题的钥匙，我们从题目中体会一下")]),t._v(" "),n("h2",{attrs:{id:"_53-最大子序和"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_53-最大子序和"}},[t._v("#")]),t._v(" 53. 最大子序和")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例 1：\n\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n示例 2：\n\n输入：nums = [1]\n输出：1\n示例 3：\n\n输入：nums = [0]\n输出：0\n复制代码\n")])])]),n("p",[t._v("思路：")]),t._v(" "),n("ul",[n("li",[t._v("这道题可以用动态规划来解决，关键是找动态转移方程")]),t._v(" "),n("li",[t._v("我们动态转移方程中，dp表示每一个nums下标的最大自序和，所以dp[i]的意思为：包括下标i之前的最大连续子序列和为dp[i]。")])]),t._v(" "),n("p",[t._v("确定转义方程的公示：")]),t._v(" "),n("p",[t._v("dp[i]只有两个方向可以推出来：")]),t._v(" "),n("ul",[n("li",[t._v("1、如果dp[i - 1] < 0，也就是当前遍历到nums的i，之前的最大子序和是负数，那么我们就没必要继续加它了，因为dp[i] = dp[i - 1] + nums[i] 会比nums[i]更小，所以此时还不如dp[i] = nums[i]，就是目前遍历到i的最大子序和呢")]),t._v(" "),n("li",[t._v("2、同理dp[i - 1] > 0，说明nums[i]值得去加dp[i - 1]，此时回避nums[i]更大")])]),t._v(" "),n("p",[t._v("这样代码就出来了，其实更多的就是求dp，遍历nums每一个下标都会产生最大子序和，我们记录下来即可")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var maxSubArray = function(nums) {\n  let res = nums[0];\n  const dp = [nums[0]];\n  for(let i=1;i < nums.length;i++){\n      if(dp[i-1]>0){\n        dp[i]=nums[i]+dp[i-1]\n      }else{\n       dp[i]=nums[i]\n      }\n      \n    res=Math.max(dp[i],res)\n  }\n    return res\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_70-爬楼梯"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_70-爬楼梯"}},[t._v("#")]),t._v(" 70. 爬楼梯")]),t._v(" "),n("p",[t._v("先看题目：")]),t._v(" "),n("p",[t._v("假设你正在爬楼梯。需要 n 阶你才能到达楼顶。")]),t._v(" "),n("p",[t._v("每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？")]),t._v(" "),n("p",[t._v("注意：给定 n 是一个正整数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n复制代码\n")])])]),n("p",[t._v("涉及到动态规划，一定要知道动态转移方程，有了这个，就相当于解题的钥匙，")]),t._v(" "),n("p",[t._v("这道题我们假设"),n("code",[t._v("dp[10]")]),t._v("表示爬到是你爬到"),n("code",[t._v("10")]),t._v("阶就到达楼顶的方法数，")]),t._v(" "),n("p",[t._v("那么，"),n("code",[t._v("dp[10]")]),t._v(" 是不是就是你爬到8阶，然后再走"),n("code",[t._v("2")]),t._v("步就到了，还有你走到"),n("code",[t._v("9")]),t._v("阶，再走"),n("code",[t._v("1")]),t._v("步就到了，")]),t._v(" "),n("p",[t._v("所以 "),n("code",[t._v("dp[10]")]),t._v(" 是不是等于 "),n("code",[t._v("dp[9]+dp[8]")])]),t._v(" "),n("p",[t._v("延伸一下 "),n("code",[t._v("dp[n]")]),t._v(" 是不是等于 "),n("code",[t._v("dp[n \\- 1] + dp[n \\- 2]")])]),t._v(" "),n("p",[t._v("代码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var climbStairs = function(n) {\n    const dp = {};\n    dp[1] = 1;\n    dp[2] = 2;\n    for(let i = 3; i <= n; i++){\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n    return dp[n]\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"数学问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数学问题"}},[t._v("#")]),t._v(" 数学问题")]),t._v(" "),n("p",[t._v("以下更多的是涉及数学问题，这些解法非常重要，因为在中级题里面会经常用到，比如我们马上讲到的"),n("code",[t._v("加一")]),t._v("这个题， 中级的两数相加都是一个模板。")]),t._v(" "),n("h2",{attrs:{id:"_66-加一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_66-加一"}},[t._v("#")]),t._v(" 66. 加一")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。")]),t._v(" "),n("p",[t._v("最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。")]),t._v(" "),n("p",[t._v("你可以假设除了整数 0 之外，这个整数不会以零开头。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例 1：\n\n输入：digits = [1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n示例 2：\n\n输入：digits = [4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n示例 3：\n\n输入：digits = [0]\n输出：[1]\n复制代码\n")])])]),n("p",[t._v("这个题的关键有两点：")]),t._v(" "),n("ul",[n("li",[t._v("需要有一个进位的变量carry记录到底进位是几")]),t._v(" "),n("li",[t._v("还需要一个每次迭代都重置和的变量sum来帮我们算是否进位，以及进位后的数字")])]),t._v(" "),n("p",[t._v("记住这个题，这是两数字相加的套路，这次是+1，其实就是两数相加的题（腾讯面试遇到过两数相加）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var plusOne = function(digits) {\n  let carry = 1; // 进位（因为我们确定+1，初始化进位就是1）\n  for(let i = digits.length - 1; i >= 0; i--){\n      let sum = 0; // 这个变量是用来每次循环计算进位和digits[i]的值的\n      sum = digits[i] + carry; \n      digits[i] = sum % 10; // 模运算取个位数\n      carry = (sum / 10) | 0; //  除以10是取百位数，并且｜0表示舍弃小数位\n  }\n  if(digits[0] === 0) digits.unshift(carry);\n  return digits\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_69-x的平方根"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_69-x的平方根"}},[t._v("#")]),t._v(" 69 x的平方根")]),t._v(" "),n("p",[t._v("题目如下：实现 int sqrt(int x) 函数。")]),t._v(" "),n("p",[t._v("计算并返回 x 的平方根，其中 x 是非负整数。")]),t._v(" "),n("p",[t._v("由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。")]),t._v(" "),n("p",[t._v("示例 1:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入: 4\n输出: 2\n复制代码\n")])])]),n("p",[t._v("示例 2:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n复制代码\n")])])]),n("p",[t._v("这道题是典型的二分法解题，所以我们需要熟悉二分法的通用模板，我们出一个题：")]),t._v(" "),n("p",[n("strong",[t._v("在 [1, 2, 3, 4, 5, 6] 中找到 4，若存在则返回下标，不存在返回-1")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const arr = [1, 2, 3, 4, 5, 6];\nfunction getIndex1(arr, key) {\n  let low = 0;\n  const high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (key === arr[mid]) {\n      return mid;\n    }\n    if (key > arr[mid]) {\n      low = mid + 1;\n    } else {\n      height = mid - 1;\n    }\n  }\n  return -1;\n}\nconsole.log(getIndex1(arr, 5)); // 4\n复制代码\n")])])]),n("p",[t._v("所以这道题的意思就是，我们找一个数平方跟x最相近的数，二分法的用法中也有找相近数的功能")]),t._v(" "),n("p",[t._v("所以代码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var mySqrt = function(x) {\n    let [l , r] = [0, x];\n    let ans = -1;\n    while(l <= r) {\n        const mid = (l + r) >> 1;\n        if(mid * mid > x){\n            r = mid - 1\n        } else if(mid * mid < x){\n            ans = mid; // 防止越界\n            l = mid + 1;\n        } else {\n            ans = mid;\n            return ans;\n        }\n    }\n    return ans;\n};\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_171-excel表序列号"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_171-excel表序列号"}},[t._v("#")]),t._v(" 171. Excel表序列号")]),t._v(" "),n("p",[t._v("这个题比较重要，也比较基础，简而言之就是进制转换，必须牢牢掌握")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。")]),t._v(" "),n("p",[t._v("例如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('A -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n复制代码\n示例 1：\n\n输入：columnNumber = 1\n输出："A"\n示例 2：\n\n输入：columnNumber = 28\n输出："AB"\n示例 3：\n\n输入：columnNumber = 701\n输出："ZY"\n示例 4：\n\n输入：columnNumber = 2147483647\n输出："FXSHRXW"\n复制代码\n')])])]),n("p",[t._v("说白了，这就是一道26进制的问题，以前我们知道10进制转2进制就是不停的除2，把余数加起来，26进制也是一样，不停的除26")]),t._v(" "),n("p",[t._v("思路：")]),t._v(" "),n("ul",[n("li",[t._v("初始化结果 "),n("code",[t._v("ans = 0")]),t._v("，遍历时将每个字母与 "),n("code",[t._v("A")]),t._v(" 做减法，因为 "),n("code",[t._v("A")]),t._v(" 表示 "),n("code",[t._v("1")]),t._v("，所以减法后需要每个数加 "),n("code",[t._v("1")]),t._v("，计算其代表的数值 "),n("code",[t._v("num = 字母 - ‘A’ + 1")])]),t._v(" "),n("li",[t._v("因为有 26 个字母，所以相当于 "),n("code",[t._v("26 进制")]),t._v("，每 "),n("code",[t._v("26")]),t._v(" 个数则向前进一位")]),t._v(" "),n("li",[t._v("所以每遍历一位则"),n("code",[t._v("ans = ans * 26 + num")])]),t._v(" "),n("li",[t._v("以 ZY 为例，Z 的值为 "),n("code",[t._v("26")]),t._v("，Y 的值为 "),n("code",[t._v("25")]),t._v("，则结果为 "),n("code",[t._v("26 * 26 + 25=701")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var titleToNumber = function(columnTitle) {\n    let ans = 0;\n    for(let i = 0; i < columnTitle.length; i++){\n        ans = ans * 26 + (columnTitle[i].charCodeAt() - 'A'.charCodeAt() + 1)\n    }\n    return ans;\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_172-阶乘中的零"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_172-阶乘中的零"}},[t._v("#")]),t._v(" 172. 阶乘中的零")]),t._v(" "),n("p",[t._v("题目：")]),t._v(" "),n("p",[t._v("给定一个整数 n，返回 n! 结果尾数中零的数量。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例 1:\n\n输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。\n示例 2:\n\n输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.\n复制代码\n")])])]),n("p",[t._v("这道题很简单，有多少个5就有多少个0，为什么这么说呢，我们分析一下题目")]),t._v(" "),n("p",[t._v("比如说 5!，")]),t._v(" "),n("ul",[n("li",[t._v("也就是 "),n("code",[t._v("5 * 4 * 3 * 2 * 1 = 120")]),t._v("，我们发现只有1个0，怎么产生的呢，主要造成者就是 2 * 5 构造了一个0")]),t._v(" "),n("li",[t._v("再看看10!")])]),t._v(" "),n("p",[t._v("10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 其中，除了10 = 2 * 5和本身有一对2 * 5，所以有两个0，这样这道题的规律就出来了，我们再精进一步")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("p",[t._v("如上图，每四个数字都会出现一个或者多个2的因子，但是只有每 5 个数字才能找到一个或多个5的因子。所以总体上看来，2的因子是远远多于5的因子的，所以我们只需要找5的倍数就可以了。")]),t._v(" "),n("p",[t._v("我们再进一步，按照上面的说法，我们需要计算比如10的阶乘有多少个0，要把10的阶乘算出来，其实我们只需要算10有几个5就好了，为什么呢")]),t._v(" "),n("p",[t._v("我们发现只有5的倍数的阶乘，才会产生5, 所以我们需要看看阶层数有多少个5，代码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var trailingZeroes = function (n) {\n  let r = 0;\n  while (n > 1) {\n    n = Math.floor(n / 5);\n    r += n;\n  }\n  return r;\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_190-颠倒二进制位"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_190-颠倒二进制位"}},[t._v("#")]),t._v(" 190.颠倒二进制位")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("颠倒给定的 32 位无符号整数的二进制位。")]),t._v(" "),n("p",[t._v("示例 1：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入: 00000010100101000001111010011100\n输出: 00111001011110000010100101000000\n解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。\n复制代码\n")])])]),n("p",[t._v("示例 2：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：11111111111111111111111111111101\n输出：10111111111111111111111111111111\n解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，\n     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。\n复制代码\n")])])]),n("p",[t._v("这类题，就是翻转字符串，我们可以把其转为字符串，再转成数组，再reverse一下，这里我们选用数学的方式去解答，不用这种转字符串的方式。")]),t._v(" "),n("p",[t._v("解答这道题之前，我们需要了解的前置知识：")]),t._v(" "),n("ol",[n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("与预算 `&`\n")])])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1 & 1 // 1的2进制最后一位是1，得到1\n2 & 0 // 2的2进制最后一位是0，得到0\n3 & 1 // 3的2进制最后一位是1，得到1\n4 & 0 // 4的2进制最后一位是0，得到0\n复制代码\n")])])]),n("p",[t._v("所以我们知道了怎么取10进制最后1位的2进制是几。")]),t._v(" "),n("ol",[n("li",[t._v("JavaScript 使用 32 位按位运算数(意思是我们的按位运算都会转成32位，你的数字不能超过32位，会出问题)")])]),t._v(" "),n("ul",[n("li",[t._v("JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。")]),t._v(" "),n("li",[t._v("在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。")]),t._v(" "),n("li",[t._v("执行按位操作后，结果将转换回 64 位 JavaScript 数。")])]),t._v(" "),n("ol",[n("li",[n("code",[t._v("'<< 1' 运算")])])]),t._v(" "),n("p",[t._v("这个运算实际上就是把10进制乘以2，这个乘2在2进制上表现出右边填了一个0，我们距举例来说，")]),t._v(" "),n("ul",[n("li",[t._v("2的2进制是 10，2 << 1 得到4， 4的2进制是100，所以比10多了个0")]),t._v(" "),n("li",[t._v("3的2进制是 11，3 << 1 得到6。6的2进制是110，所以比11多了个0")])]),t._v(" "),n("p",[t._v("以上就是规律")]),t._v(" "),n("p",[t._v("思路：循环取最后一位拼接起来即可")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var reverseBits = function (n) {\n  let result = 0\n  for (let i = 0; i < 32; i++) {\n    result = (result << 1) + (n & 1)\n    n = n >> 1\n  }\n  // 为什么要 >>> 0 呢，一位javascript没有无符号整数，全是有符号的\n  // 不>>>0的话，得出来的值是负数，但是无符号整数是没有符号的\n  // javascript 有符号转化为无符号的方法就是>>>0\n  return result >>> 0\n}\n复制代码\n")])])]),n("h2",{attrs:{id:"_268-丢失的数字"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_268-丢失的数字"}},[t._v("#")]),t._v(" 268. 丢失的数字")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。")]),t._v(" "),n("p",[t._v("进阶：")]),t._v(" "),n("p",[t._v("你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例 1：\n\n输入：nums = [3,0,1]\n输出：2\n解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n示例 2：\n\n输入：nums = [0,1]\n输出：2\n解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n复制代码\n")])])]),n("p",[t._v("这题很简单，就是用0-n的总和减去数组总和")]),t._v(" "),n("ul",[n("li",[t._v("0 - n 的总和用等差数列:"),n("code",[t._v("（首数+尾数）* 项数 / 2")]),t._v(" 来求")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" var missingNumber = function(nums) {\n    const len = nums.length\n \n   let sum = ((1 + len) * len) / 2\n \n   for (let i = 0; i < len; i++) {\n     sum -= nums[i]\n   }\n \n   return sum\n }\n复制代码\n")])])]),n("h2",{attrs:{id:"_3的幂"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3的幂"}},[t._v("#")]),t._v(" 3的幂")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。")]),t._v(" "),n("p",[t._v("整数 n 是 3 的幂次方需满足：存在整数 x 使得 "),n("code",[t._v("n == 3的x次方")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("示例 1：\n\n输入：n = 27\n输出：true\n示例 2：\n\n输入：n = 0\n输出：false\n示例 3：\n\n输入：n = 9\n输出：true\n复制代码\n")])])]),n("p",[t._v("思路")]),t._v(" "),n("ul",[n("li",[t._v("我们拿27来说：27 = 3 * 3 * 3，所以27是3的幂次方")]),t._v(" "),n("li",[t._v("我们拿29来说：29 = 3 * 3 * 3点几")])]),t._v(" "),n("p",[t._v("也就是说，如果是3的幂次方，一直除以3，除到最后就等于1比如27/3/3/3等于1 如果不是3的幂次方，除到最后就是3点几/3 等于1点几")]),t._v(" "),n("p",[t._v("代码就出来了判断是不是等于1即可")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var isPowerOfThree = function(n) {\n    while(n >= 3){\n        n /= 3;\n    }\n    return n === 1;\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_412-fizz-buzz"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_412-fizz-buzz"}},[t._v("#")]),t._v(" 412. Fizz Buzz")]),t._v(" "),n("p",[t._v("这个题没啥好说的，就按照题目说的写代码就行，先看题目：")]),t._v(" "),n("p",[t._v("写一个程序，输出从 1 到 n 数字的字符串表示。")]),t._v(" "),n("ol",[n("li",[t._v("如果 n 是3的倍数，输出“Fizz”；")]),t._v(" "),n("li",[t._v("如果 n 是5的倍数，输出“Buzz”；")]),t._v(" "),n("li",[t._v("如果 n 同时是3和5的倍数，输出 “FizzBuzz”。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('示例：\n\nn = 15,\n\n返回:\n[\n    "1",\n    "2",\n    "Fizz",\n    "4",\n    "Buzz",\n    "Fizz",\n    "7",\n    "8",\n    "Fizz",\n    "Buzz",\n    "11",\n    "Fizz",\n    "13",\n    "14",\n    "FizzBuzz"\n]\n复制代码\n  var fizzBuzz = function (n) {\n    const list = [];\n    for (let i = 1; i <= n; i++) {\n      const is3Times = i % 3 === 0; // 是否是3的倍数\n      const is5Times = i % 5 === 0; // 是否是5的倍数\n      const is15Times = is3Times && is5Times; // 是否是15的倍数\n      if (is15Times) {\n        list.push(\'FizzBuzz\');\n        continue;\n      }\n      if (is3Times) {\n        list.push(\'Fizz\');\n        continue;\n      }\n      if (is5Times) {\n        list.push(\'Buzz\');\n        continue;\n      }\n      list.push(`${i}`);\n    }\n    return list;\n  };\n复制代码\n')])])]),n("ul",[n("li"),t._v(" "),n("li",[n("ol",[n("li",[t._v("整数反转")])])])]),t._v(" "),n("p",[t._v("这个题跟之前的excel序号题差不多，我们先看题目：")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("屏幕快照 2021-07-27 上午10.55.40.png")]),t._v(" "),n("p",[t._v("思路如下：这道题可以将数字转字符串然后翻转，我们不用这种方法，用更纯正的数学方法，速度和效率更好。")]),t._v(" "),n("p",[t._v("假设我们有一个数字12345，下图展示了翻转的过程")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var reverse = function(x) {\n    let ret = 0;\n    while(x){\n        ret = ret * 10 + x % 10;\n        if(ret > Math.pow(2, 31) - 1 || ret < Math.pow(-2, 31)) return 0;\n        x = (x / 10) | 0\n    }\n    return ret\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"环问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#环问题"}},[t._v("#")]),t._v(" 环问题")]),t._v(" "),n("p",[t._v("这类问题的特点就是，你要循环寻找，到底怎么循环寻找，看题便知。")]),t._v(" "),n("h2",{attrs:{id:"_141-环形链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_141-环形链表"}},[t._v("#")]),t._v(" 141. 环形链表")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给定一个链表，判断链表中是否有环。")]),t._v(" "),n("p",[t._v("如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。")]),t._v(" "),n("p",[t._v("如果链表中存在环，则返回 true 。否则，返回 false 。")]),t._v(" "),n("p",[n("strong",[t._v("示例 1：")])]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：head = [3,2,0,-4], pos = 1\n输出： true\n解释： 链表中有一个环，其尾部连接到第二个节点。\n复制代码\n")])])]),n("p",[n("strong",[t._v("示例 2：")]),n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：head = [1,2], pos = 0\n输出： true\n解释： 链表中有一个环，其尾部连接到第一个节点。\n复制代码\n")])])]),n("p",[t._v("我们采用标记法：")]),t._v(" "),n("p",[t._v("给遍历过的节点打记号，如果遍历过程中遇到有记号的说明已环")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var hasCycle = function(head) {\n    let traversingNode = head;\n    while(traversingNode){\n        if(traversingNode.isVistitd) return true\n        traversingNode.isVistitd = true\n        traversingNode = traversingNode.next\n    }\n    return false;\n};\n复制代码\n")])])]),n("h2",{attrs:{id:"_160-相交链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_160-相交链表"}},[t._v("#")]),t._v(" 160. 相交链表")]),t._v(" "),n("p",[t._v("题目如下：")]),t._v(" "),n("p",[t._v("给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。")]),t._v(" "),n("p",[t._v("图示两个链表在节点 c1 开始相交：")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("p",[t._v("题目数据 "),n("strong",[t._v("保证")]),t._v(" 整个链式结构中不存在环。")]),t._v(" "),n("p",[n("strong",[t._v("注意")]),t._v("，函数返回结果后，链表必须 "),n("strong",[t._v("保持其原始结构")]),t._v(" 。")]),t._v(" "),n("p",[t._v("示例 1：")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n复制代码\n")])])]),n("p",[t._v("示例 2：")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n复制代码\n")])])]),n("p",[t._v("稍后更新本文章")]),t._v(" "),n("h2",{attrs:{id:"_202-快乐数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_202-快乐数"}},[t._v("#")]),t._v(" 202. 快乐数")]),t._v(" "),n("p",[t._v("题目如下：编写一个算法来判断一个数 n 是不是快乐数。")]),t._v(" "),n("p",[t._v("「快乐数」定义为：")]),t._v(" "),n("ul",[n("li",[t._v("对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。")]),t._v(" "),n("li",[t._v("然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。")]),t._v(" "),n("li",[t._v("如果 可以变为 1，那么这个数就是快乐数。")]),t._v(" "),n("li",[t._v("如果 n 是快乐数就返回 true ；不是，则返回 false 。")])]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("p",[t._v("快乐数怎么分析呢？")]),t._v(" "),n("p",[t._v("我们来看一个表，就会得出结论，一个数按照快乐数定义的方式分别每个数字平方，会有两种情况")]),t._v(" "),n("ul",[n("li"),t._v(" "),n("li",[n("ol",[n("li",[t._v("得到"),n("code",[t._v("1")])])])]),t._v(" "),n("li"),t._v(" "),n("li",[n("ol",[n("li",[t._v("无限循环")])])])]),t._v(" "),n("p",[t._v("无限循环参照下图")]),t._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),t._v("image.png")]),t._v(" "),n("p",[t._v("有人会说会不会一直变大，答案是不会：我们看下面列表，")]),t._v(" "),n("ul",[n("li",[t._v("可以看到如果你是13位，你的下一次快乐数算法会变为4位1053，")]),t._v(" "),n("li",[t._v("如果你是"),n("code",[t._v("9999")]),t._v(", "),n("code",[t._v("4")]),t._v("位，下一个快乐数是"),n("code",[t._v("324")])])]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("位数")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("位数对应最大值")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("下一个快乐数")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("9")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("81")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("99")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("162")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("999")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("243")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("9999")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("324")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("13")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("9999999999999")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("1053")])])])]),t._v(" "),n("p",[t._v("所以代码只要判断这两种就行了，代码如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 封装获取快乐数的方法\nfunction getNext(n){\n    n = String(n);\n    let sum = 0;\n    for(let num of n){\n        sum = sum + Math.pow(+num, 2);\n    }\n    return sum;\n}\nvar isHappy = function(n) {\n    // 哈希表来看是否循环\n    const map = {};\n    while( n !== 1 ){\n        map[n] = true;\n        n = getNext(n)\n        if(map[n]) return false\n    }\n    return true\n};\n复制代码\n")])])]),n("p",[t._v("后面会写中级算法的题，请大家务必把这些基础算法题掌握好，基础不牢地动山摇，后面中级题很多都是在这些基础题的基础上的。")]),t._v(" "),n("p",[t._v("源自：https://juejin.cn/post/6989031479753834504")])])}),[],!1,null,null,null);n.default=s.exports}}]);