(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{422:function(a,e,t){"use strict";t.r(e);var n=t(4),s=Object(n.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"送你-54-道-javascript-面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#送你-54-道-javascript-面试题"}},[a._v("#")]),a._v(" 送你 54 道 JavaScript 面试题")]),a._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/ejdZjDjk87xr-VBYNVzYQw",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://mp.weixin.qq.com/s/ejdZjDjk87xr-VBYNVzYQw"),e("OutboundLink")],1)])]),a._v(" "),e("h3",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("blockquote",[e("p",[a._v("大家好，我叫TianTian，一个爱瞎折腾，爱算法的Acmer爱好者，梳理一些比较好的JS题目，复习完还是收获很大，分享给大家❤️")])]),a._v(" "),e("p",[a._v("题目主要来自看到过的易错题，还有经典的"),e("strong",[a._v("44道 JavaScript Puzzlers!")]),a._v("，出自原文链接")]),a._v(" "),e("p",[e("strong",[a._v("stackoverflow")]),a._v(" 这上面有很多Questions不错的，可以好好补一补基础")]),a._v(" "),e("blockquote",[e("p",[a._v("JS易错题暂时很长一段时间就不更新啦，TypeScript都出来了，TS真香")]),a._v(" "),e("p",[a._v("➡️给个小建议，可以先看完第一题，要是没有问题的话，后面的基本上也可以跳过")])]),a._v(" "),e("p",[a._v("GitHub仓库点这里")]),a._v(" "),e("p",[a._v("开始吧👇")]),a._v(" "),e("h3",{attrs:{id:"vs-操作符优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vs-操作符优先级"}},[a._v("#")]),a._v(" "),e("code",[a._v(".")]),a._v(" VS "),e("code",[a._v("=")]),a._v(" 操作符优先级")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  let a = {n : 1};\n        let b = a;\n        a.x = a = {n: 2};\n\n        \n        console.log(a.x)\n        console.log(b.x)\n")])])]),e("p",[a._v("输出是什么呢？")]),a._v(" "),e("p",[a._v("真的想明白了吗？")]),a._v(" "),e("p",[e("strong",[a._v("答案")])]),a._v(" "),e("p",[a._v("undefined")]),a._v(" "),e("p",[a._v("{ n : 2}")]),a._v(" "),e("h3",{attrs:{id:"你真的了解作用域吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#你真的了解作用域吗"}},[a._v("#")]),a._v(" 你真的了解作用域吗")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  var a = 0,  \n            b = 0;\n        function A(a) {\n            A = function (b) {\n                console.log(a + b++)\n            }\n            console.log(a++)\n        }\n        A(1)\n        A(2)\n")])])]),e("p",[a._v("留给你们思考，我可是第一遍就做错了(；′⌒`)")]),a._v(" "),e("p",[e("strong",[a._v("答案 1 4")])]),a._v(" "),e("p",[a._v("可以好好想一想，你会茅塞顿开的。")]),a._v(" "),e("h3",{attrs:{id:"类数组的length"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类数组的length"}},[a._v("#")]),a._v(" 类数组的length")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('  var obj = {\n            "2" : 3,\n            "3" : 4,\n            "length" : 2,\n            "splice" : Array.prototype.splice,\n            "push" : Array.prototype.push\n        }\n        obj.push(1)\n        obj.push(2)\n        console.log(obj)\n')])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("解释就是第一次使用push,obj对象的push方法设置obj[2] = 1,obj.length++\n\n解释就是第一次使用push,obj对象的push方法设置obj[3] = 2,obj.length++\n\n使用console.log()方法输出的时候，因为obj上有length属性和splice方法，故将其作为数组输出打印\n\n打印时因为数组未设置下标为0和1的值，故打印的结果就是empty，主动获取obj[0] = undefined\n")])])]),e("h3",{attrs:{id:"非匿名自执行函数-函数名只读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非匿名自执行函数-函数名只读"}},[a._v("#")]),a._v(" 非匿名自执行函数，函数名只读")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  var b = 10;\n        (function b(){\n            // 'use strict'\n            b = 20\n            console.log(b)\n        })()\n")])])]),e("p",[a._v("输出的结果是什么？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Function b\n- 如标题一样，非匿名自执行函数，函数名不可以修改，严格模式下会TypeError，\n- 非严格模式下，不报错，修改也没有用。\n- 查找变量b时,立即执行函数会有内部作用域，会先去查找是否有b变量的声明，有的话，直接复制\n- 确实发现具名函数Function b(){} 所以就拿来做b的值\n- IIFE的函数内部无法进行复制(类似于const)\n")])])]),e("h3",{attrs:{id:"非匿名自执行函数-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非匿名自执行函数-ii"}},[a._v("#")]),a._v(" 非匿名自执行函数 II")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  var b = 10;\n        (function b(){\n            // 'use strict'\n            var b = 20\n            console.log(window.b) \n            console.log(b)\n        })()\n")])])]),e("p",[a._v("输出是多少呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("10\n20\n// 访问b变量的时候,发现var b = 20;在当前作用域中找到了b变量，于是把b的值作为20\n")])])]),e("h3",{attrs:{id:"非匿名自执行函数-iii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非匿名自执行函数-iii"}},[a._v("#")]),a._v(" 非匿名自执行函数 III")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  var b = 10;\n        (function b(){\n            console.log(b)\n            b = 5\n            console.log(window.b)\n            var b = 20\n            console.log(b)\n        })()\n")])])]),e("p",[a._v("输出的结果是多少呢？")]),a._v(" "),e("p",[a._v("这个问题应该不难，就留给你们思考吧")]),a._v(" "),e("h3",{attrs:{id:"变量提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[a._v("#")]),a._v(" 变量提升")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n")])])]),e("p",[a._v("在 JavaScript中， Fun 和 var 会被提升")]),a._v(" "),e("p",[a._v("相当于")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var name = 'World!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n")])])]),e("p",[a._v("巩固一下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" var str = 'World!';   \n    (function (name) {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n    })(str);\n    答案：Hello World 因为name已经变成函数内局部变量\n")])])]),e("h3",{attrs:{id:"最大整数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最大整数"}},[a._v("#")]),a._v(" 最大整数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count);\n")])])]),e("p",[a._v("一个知识点:Infinity")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.\n")])])]),e("h3",{attrs:{id:"稀疏数组与密数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#稀疏数组与密数组"}},[a._v("#")]),a._v(" 稀疏数组与密数组")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;});\n")])])]),e("p",[a._v("执行结果如何呢？")]),a._v(" "),e("p",[a._v("做这个题目，你需要了解稀疏数组和密集数组")]),a._v(" "),e("ul",[e("li",[a._v("译 JavaScript中的稀疏数组与密集数组")]),a._v(" "),e("li",[a._v("Array/filter")])]),a._v(" "),e("p",[a._v("看过源码的同学应该知道，filter源码中，会去判断数组的这个索引值是不是数组的一个属性，有兴趣的同学可以看看我写的这篇关于数组的：[干货👍]从详细操作js数组到浅析v8中array.js")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("0 in ary; => true\n3 in ary; => false\n10 in ary; => true\n也就是说 从 3 - 9 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些'坑'的.\n")])])]),e("p",[a._v("所以答案就是[]")]),a._v(" "),e("h3",{attrs:{id:"浮点运算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浮点运算"}},[a._v("#")]),a._v(" 浮点运算")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var two   = 0.2\nvar one   = 0.1\nvar eight = 0.8\nvar six   = 0.6\n[two - one == one, eight - six == two]\n")])])]),e("p",[a._v("你认为结果是多少呢？面试遇到这个问题，应该怎么回答呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[true,false]\n")])])]),e("p",[a._v("可以看看这些文章：")]),a._v(" "),e("ul",[e("li",[a._v("探寻 JavaScript 精度问题以及解决方案")]),a._v(" "),e("li",[a._v("从0.1+0.2=0.30000000000000004再看JS中的Number类型")])]),a._v(" "),e("h3",{attrs:{id:"switch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#switch"}},[a._v("#")]),a._v(" Switch")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A'));\n")])])]),e("p",[a._v("运行结果如何呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("switch 是严格比较, String 实例和 字符串不一样.\n答案自然是'Do not know' \n所以一般情况下,写switch语句，也建议写default\n")])])]),e("p",[a._v('String("A")')]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A'));\n")])])]),e("p",[a._v("运行结果呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：Case A\n解析：String('A')就是返回一个字符串\n")])])]),e("h3",{attrs:{id:"运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运算符"}},[a._v("#")]),a._v(" %运算符")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function isOdd(num) {\n    return num % 2 == 1;\n}\nfunction isEven(num) {\n    return num % 2 == 0;\n}\nfunction isSane(num) {\n    return isEven(num) || isOdd(num);\n}\nvar values = [7, 4, '13', -9, Infinity];\nvalues.map(isSane);\n")])])]),e("p",[a._v("运行的结果如何呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：[true, true, true, false, false]\n解析：%如果不是数值会调用Number（）去转化\n     '13' % 2       // 1\n      Infinity % 2  //NaN  Infinity 是无穷大\n      -9 % 2        // -1\n巩固：9 % -2        // 1   余数的正负号随第一个操作数\n")])])]),e("h3",{attrs:{id:"数组的原型是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组的原型是什么"}},[a._v("#")]),a._v(" 数组的原型是什么")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Array.isArray( Array.prototype )\n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：true\n解析：Array.prototype是一个数组\n数组的原型是数组，对象的原型是对象，函数的原型是函数\n")])])]),e("h3",{attrs:{id:"宽松相等"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宽松相等"}},[a._v("#")]),a._v(" 宽松相等 ==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[]==[]\n")])])]),e("p",[a._v("答案是什么呢")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：false\n解析：两个引用类型， ==比较的是引用地址\n")])])]),e("h3",{attrs:{id:"和-优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和-优先级"}},[a._v("#")]),a._v(" == 和 !优先级")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[]== ![] \n")])])]),e("p",[a._v("结果是什么呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("(1)! 的优先级高于== ，右边Boolean([])是true,取返等于 false\n(2)一个引用类型和一个值去比较 把引用类型转化成值类型，左边0\n(3)所以 0 == false  答案是true\n")])])]),e("h3",{attrs:{id:"数字与字符串相加减"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数字与字符串相加减"}},[a._v("#")]),a._v(" 数字与字符串相加减")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'5' + 3\n'5' - 3\n")])])]),e("p",[a._v("结果是多少呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('答案：53  2\n解析：加号有拼接功能，减号就是逻辑运算\n巩固：typeof (+"1")   // "number" 对非数值+—常被用来做类型转换相当于Number()\n')])])]),e("h3",{attrs:{id:"一波骚操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一波骚操作"}},[a._v("#")]),a._v(" 一波骚操作  + - + + + - +")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1 + - + + + - + 1\n")])])]),e("p",[a._v("结果是多少呢")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：2\n解析：+-又是一元加和减操作符号，就是数学里的正负号。负负得正哈。 \n巩固： 一元运算符还有一个常用的用法就是将自执行函数的function从函数声明变成表达式。\n      常用的有 + - ～ ！void\n      + function () { }\n      - function () { }\n      ~ function () { }\n      void function () { }\n")])])]),e("h3",{attrs:{id:"又是稀疏数组-array-prototype-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#又是稀疏数组-array-prototype-map"}},[a._v("#")]),a._v(" 又是稀疏数组？Array.prototype.map()")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n")])])]),e("p",[a._v("输出结果是多少呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("稀疏数组\n\n题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的'坑'.\n\n所以答案是 [\"1\", empty × 2]\n")])])]),e("p",[a._v("这里贴上 Array.prototype.map 的 polyfill.")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Array.prototype.map = function(callback, thisArg) {\n\n        var T, A, k;\n\n        if (this == null) {\n            throw new TypeError(' this is null or not defined');\n        }\n\n        var O = Object(this);\n        var len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        A = new Array(len);\n        k = 0;\n        while (k < len) {\n            var kValue, mappedValue;\n            if (k in O) {\n                kValue = O[k];\n                mappedValue = callback.call(T, kValue, k, O);\n                A[k] = mappedValue;\n            }\n            k++;\n        }\n        return A;\n    };\n")])])]),e("h3",{attrs:{id:"js是如何存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js是如何存储"}},[a._v("#")]),a._v(" JS是如何存储")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 111111111111111110000,\nb = 1111;\na + b;\n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：11111111111111111000\n解析：在JavaScript中number类型在JavaScript中以64位（8byte）来存储。\n这64位中有符号位1位、指数位11位、实数位52位。\n2的53次方时，是最大值。\n其值为：9007199254740992（0x20000000000000）。\n超过这个值的话，运算的结果就会不对.\n")])])]),e("h3",{attrs:{id:"数组比较大小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组比较大小"}},[a._v("#")]),a._v(" 数组比较大小")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = [1, 2, 3],\n    b = [1, 2, 3],\n    c = [1, 2, 4]\na ==  b\na === b\na >   c\na <   c\n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：false, false, false, true\n解析：相等（==）和全等（===）还是比较引用地址\n     引用类型间比较大小是按照字典序比较，就是先比第一项谁大，相同再去比第二项。\n")])])]),e("h3",{attrs:{id:"三元运算符优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三元运算符优先级"}},[a._v("#")]),a._v(" 三元运算符优先级")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var val = 'smtg';\nconsole.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');\n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：Something\n解析：字符串连接比三元运算有更高的优先级 \n     所以原题等价于 'Value is true' ? 'Somthing' : 'Nonthing' \n     而不是 'Value   is' + (true ? 'Something' : 'Nonthing')\n巩固：\n    1 || fn() && fn()   //1  \n    1 || 1 ? 2 : 3 ;    //2  \n")])])]),e("h3",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[a._v("#")]),a._v(" 原型")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = {}, b = Object.prototype;\n[a.prototype === b, Object.getPrototypeOf(a) === b] \n")])])]),e("p",[a._v("执行结果是多少呢")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：false, true\n解析：Object 的实例是 a，a上并没有prototype属性\n     a的__poroto__ 指向的是Object.prototype，也就是Object.getPrototypeOf(a)。a的原型对象是b\n")])])]),e("h3",{attrs:{id:"原型ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型ii"}},[a._v("#")]),a._v(" 原型II")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b         \n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：false\n解析：a是构造函数f的原型 ： {constructor: ƒ}\nb是实例f的原型对象 ： ƒ () { [native code] }\n")])])]),e("h3",{attrs:{id:"函数名称"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数名称"}},[a._v("#")]),a._v(" 函数名称")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function foo() { }\nvar oldName = foo.name;\nfoo.name = "bar";\n[oldName, foo.name]     \n')])])]),e("p",[a._v("代码执行结果是什么？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('答案：["foo", "foo"]\n解析：函数的名字不可变.\n')])])]),e("h3",{attrs:{id:"typeof-null-null-instanceof-object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typeof-null-null-instanceof-object"}},[a._v("#")]),a._v(" [typeof null, null instanceof Object]")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('答案：["object", false]\n解析：null代表空对象指针，所以typeof判断成一个对象。可以说JS设计上的一个BUG\n     instanceof 实际上判断的是对象上构造函数，null是空当然不可能有构造函数\n巩固：null == undefined //true    null === undefined //flase\n')])])]),e("h3",{attrs:{id:"_3-2-1-reduce-math-pow-reduce-math-pow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-reduce-math-pow-reduce-math-pow"}},[a._v("#")]),a._v(" [ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：Error\n解析：Math.pow (x , y)  x 的 y 次幂的值\n     reduce（fn,total）\n     fn (total, currentValue, currentIndex, arr) \n         如果一个函数不传初始值，数组第一个组默认为初始值.\n         [3,2,1].reduce(Math.pow)\n         Math.pow(3,2) //9\n         Math.pow(9,1) //9\n\n巩固题,可以做一做：\n  [].reduce(Math.pow)       //空数组会报TypeError\n     [1].reduce(Math.pow)      //只有初始值就不会执行回调函数，直接返回1\n     [].reduce(Math.pow,1)     //只有初始值就不会执行回调函数，直接返回1\n     [2].reduce(Math.pow,3)    //传入初始值，执行回调函数，返回9\n")])])]),e("h3",{attrs:{id:"replace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#replace"}},[a._v("#")]),a._v(" replace")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('"1 2 3".replace(/\\d/g, parseInt)\n')])])]),e("p",[a._v("输出是什么呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：\"1 NaN 3\"\n解析：replace() 回调函数的四个参数:\n      1、匹配项  \n      2、与模式中的子表达式匹配的字符串  \n      3、出现的位置  \n      4、stringObject 本身 。\n如果没有与子表达式匹配的项，第二参数为出现的位置.所以第一个参数是匹配项，第二个参数是位置\n parseInt('1', 0)\n parseInt('2', 2)  //2进制中不可能有2\n parseInt('3', 4)\n")])])]),e("h3",{attrs:{id:"eval用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eval用法"}},[a._v("#")]),a._v(" eval用法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // ?\nparent.name // ?\ntypeof eval(f.name) // ?\ntypeof eval(parent.name) //  ?  \n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('答案："f", "Empty", "function", error\n解析：f的函数名就是f\n     parent是f原型对象的名字为"" ,\n     先计算eval(f.name) 为 f,f的数据类型是function\n     eval(parent.name) 为undefined, "undefined"\n')])])]),e("h3",{attrs:{id:"new-date"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-date"}},[a._v("#")]),a._v(" new  Date()")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var a = new Date("2014-03-19"),\nb = new Date(2014, 03, 19);\n[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]\n')])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('答案：[false, false]\n解析：var a = new Date("2014-03-19")    //能够识别这样的字符串，返回想要的日期\n      Wed Mar 19 2014 08:00:00 GMT+0800 (CST)\n      b = new Date(2014, 03, 19);       //参数要按照索引来\n      Sat Apr 19 2014 00:00:00 GMT+0800 (CST)\n      月是从0索引，日期是从1 \n      getDay()是获取星期几\n      getMonth()是获取月份所以都不同\n巩固： [a.getDate() === b.getDate()] //true\n')])])]),e("h3",{attrs:{id:"new-date-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-date-ii"}},[a._v("#")]),a._v(" new  Date() II")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n")])])]),e("p",[a._v("这段代码的执行结果？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：[false, false, false]\n解析：当日期被作为构造函数调用时，它返回一个相对于划时代的对象（JAN 01 1970）。\n当参数丢失时，它返回当前日期。当它作为函数调用时，它返回当前时间的字符串表示形式。\na是字符串   a === b // 数据类型都不同，肯定是false\nb是对象     b === c // 引用类型，比的是引用地址\nc也是对象   a === c // 数据类型都不同，肯定是false\n")])])]),e("h3",{attrs:{id:"new-date-iii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-date-iii"}},[a._v("#")]),a._v(" new  Date() III")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var a = new Date("epoch")\n')])])]),e("p",[a._v("你认为结果是多少呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：Invalid Date {}\n解析：您得到“无效日期”，这是一个实际的日期对象（一个日期的日期为true）。但无效。这是因为时间内部保持为一个数字，在这种情况下，它是NA。\n      在chrome上是undefined \n      正确的是格式是var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);\n")])])]),e("h3",{attrs:{id:"function-length"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function-length"}},[a._v("#")]),a._v(" Function.length")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = Function.length,\nb = new Function().length\na === b\n")])])]),e("p",[a._v("这段代码的执行结果是？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("答案：false\n解析：首先new在函数带（）时运算优先级和.一样所以从左向右执行\n     new Function() 的函数长度为0\n巩固：function fn () {\n         var a = 1;\n      }\n      console.log(fn.length) \n      //0 fn和new Function()一样\n")])])]),e("blockquote",[e("p",[a._v("要是看过往期的这篇文章[诚意满满✍]带你填一些JS容易出错的坑 就可以给我点个赞👍关注一下啦，下面的内容都是这篇文章的内容。")])]),a._v(" "),e("h3",{attrs:{id:"_1-2-5-10-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-5-10-sort"}},[a._v("#")]),a._v(" [1,2,5,10].sort()")]),a._v(" "),e("p",[a._v("不写回调函数的话，是按照什么排序呢？")]),a._v(" "),e("p",[a._v("JavaScript默认使用字典序(alphanumeric)来排序。因此结果是[1,10,2,5]")]),a._v(" "),e("p",[a._v("正确排序的话，应该[1,2,5,10].sort( (a,b) => a-b )")]),a._v(" "),e("h3",{attrs:{id:"b-a-a-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-a-a-a"}},[a._v("#")]),a._v(' "b" + "a" + +"a" + "a"')]),a._v(" "),e("p",[a._v("你认为输出是什么？")]),a._v(" "),e("p",[a._v("上面的表达式相当于'b'+'a'+ (+'a')+'a'，因为（+'a'）是NaN，所以：")]),a._v(" "),e("p",[a._v("'b'+'a'+ (+'a')+'a' = 'b'+'a'+ \"NaN\"+'a'='baNaNa'")]),a._v(" "),e("h3",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),e("p",[a._v("这是一个经典JavaScript面试题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  let res = new Array()\n        for(var i = 0; i < 10; i++){\n            res.push(function(){\n                return console.log(i)\n            })\n        }\n        res[0]() \n        res[1]()\n        res[2]()\n")])])]),e("p",[a._v("期望输出的是0,1,2,实际上却不会。原因就是涉及"),e("strong",[a._v("作用域")]),a._v("，怎么解决呢？")]),a._v(" "),e("ul",[e("li",[a._v("[x] 使用let代替var，形成块级作用域")]),a._v(" "),e("li",[a._v("[x] 使用bind函数。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("res.push(console.log.bind(null, i))\n")])])]),e("p",[a._v("解法还有其他的，比如使用IIFE，形成私有作用域等等做法。")]),a._v(" "),e("h3",{attrs:{id:"又一经典闭包问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#又一经典闭包问题"}},[a._v("#")]),a._v(" 又一经典闭包问题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\n")])])]),e("p",[e("strong",[a._v("留给你们思考")])]),a._v(" "),e("h3",{attrs:{id:"隐式转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隐式转换"}},[a._v("#")]),a._v(" 隐式转换")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var a = [0];\nif (a) {\n  console.log(a == true);\n} else {\n  console.log("wut");\n}\n')])])]),e("p",[a._v("你们觉得答案是多少呢？这题涉及到隐式转换了，这个坑我自己的好好补一补")]),a._v(" "),e("p",[a._v("// 答案：false")]),a._v(" "),e("p",[e("strong",[a._v("再来一道？")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function fn() {\n    return 20;\n}\nconsole.log(fn + 10); // 输出结果是多少\nfunction fn() {\n    return 20;\n}\nfn.toString = function() {\n    return 10;\n}\nconsole.log(fn + 10);  // 输出结果是多少？\nfunction fn() {\n    return 20;\n}\n\nfn.toString = function() {\n    return 10;\n}\n\nfn.valueOf = function() {\n    return 5;\n}\n\nconsole.log(fn + 10); // 输出结果是多少？\n")])])]),e("p",[e("strong",[a._v("说到底JS类型转换的好好补一补了")])]),a._v(" "),e("h3",{attrs:{id:"你真的理解操作符吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#你真的理解操作符吗"}},[a._v("#")]),a._v(" 你真的理解操作符吗")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[1<2<3,3<2<1]\n//[false,false]\n//[true,true]\n//[false,true]\n//[true,false]\n")])])]),e("p",[a._v("选一个吧，比较操作符，赋值运算符优先级哪个更高呢？")]),a._v(" "),e("h3",{attrs:{id:"_0-1-0-2-0-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-0-3"}},[a._v("#")]),a._v(" 0.1+0.2  !== 0.3  ?")]),a._v(" "),e("p",[a._v("面试的时候，问你这个问题，要是回答错误的话，估计面试官对基础很是怀疑！！！")]),a._v(" "),e("p",[a._v("问你这个题目的时候，你可以牵扯出很多问题，比如JS如何存储小数的呢？比如聊一聊二进制，比如实际开发中，遇到精度的问题，你是怎么解决的，你有什么好办法。")]),a._v(" "),e("p",[a._v("聊完这个，你可以牵扯出最大安全数，比如JavaScript的最大安全整数是多少，超出这个范围的话，怎么解决精度问题呢？")]),a._v(" "),e("p",[a._v("ES规范中新提出的BigInt解决了什么问题呢，你又发现了BigInt中哪些坑呢？")]),a._v(" "),e("p",[a._v("如何解决精度问题呢？")]),a._v(" "),e("p",[a._v("这里推荐Number-Precision库，不到1K的体积。")]),a._v(" "),e("h3",{attrs:{id:"arguments"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#arguments"}},[a._v("#")]),a._v(" arguments")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  function sidEffecting(ary) {\n            ary[0] = ary[2];\n        }\n        function bar(a, b, c) {\n            c = 10\n            sidEffecting(arguments);\n            return a + b + c;\n        }\n        function demo (arg) {\n            arg.name = 'new Name'\n        }\n        console.log(bar(2, 2, 2))\n")])])]),e("p",[a._v("涉及到ES6语法，这题答案肯定都会做是22，但是呢，稍微改变一下题目，就比较坑了….")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  function sidEffecting(ary) {\n            ary[0] = ary[2];\n        }\n        function bar(a, b, c = 4) {\n            c = 10\n            sidEffecting(arguments);\n            return a + b + c;\n        }\n        function demo (arg) {\n            arg.name = 'new Name'\n        }\n        console.log(bar(2, 2, 2))\n")])])]),e("p",[a._v("这个答案是多少呢？根据MDN上对argument有更加准确的定义，看argument")]),a._v(" "),e("blockquote",[e("p",[a._v("当非严格模式中的函数"),e("strong",[a._v("有")]),a._v("包含剩余参数、默认参数和解构赋值，那么"),e("code",[a._v("arguments")]),a._v("对象中的值"),e("strong",[a._v("不会")]),a._v("跟踪参数的值（反之亦然）。")])]),a._v(" "),e("p",[a._v("找到这句话，bar函数存在默认参数，并且在非严格模式下，所以不会跟踪参数的值，自然结果就14")]),a._v(" "),e("p",[e("strong",[a._v("请读者细细体会")])]),a._v(" "),e("h3",{attrs:{id:"浏览器懵逼史"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器懵逼史"}},[a._v("#")]),a._v(" 浏览器懵逼史")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  let demo1 = {class: \"Animal\", name: 'sheet'};\n        console.log(demo1.class)\n")])])]),e("p",[a._v("比较流氓，这个跟浏览器相关，class是保留字（现在的话，class是关键字），答案并不要紧，重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a['class']。")]),a._v(" "),e("p",[e("strong",[a._v("保留字vs关键字")])]),a._v(" "),e("p",[a._v("个人理解的话，关键字就是有特殊含义的，不用用作变量名。比如")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let class = 123;\n")])])]),e("p",[a._v("现在看来肯定报错，那有什么需要我们注意的呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let undefined = 123;\n")])])]),e("p",[a._v("这样子并不会报错，这个跟浏览器有点关系，这样子看来undefined不是关键字。所以为了保险起见，"),e("strong",[a._v("建议大家在判断一个变量是不是未定义的话，尽量使用void 0 === undefined")]),a._v("很有可能undefined会被当作是变量来赋值")]),a._v(" "),e("p",[e("strong",[a._v("void 0 值就是undefined")])]),a._v(" "),e("h3",{attrs:{id:"_1-2-3-map-parseint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-map-parseint"}},[a._v("#")]),a._v(' ["1", "2", "3"].map(parseInt)')]),a._v(" "),e("p",[a._v("这个应该是经常遇见的题了，搞明白很简单，map函数怎么使用，parseInt函数怎么使用")]),a._v(" "),e("p",[a._v("关于Array数组的话，我之前写了一篇文章，从"),e("strong",[a._v("源码角度解析大部分方法")])]),a._v(" "),e("p",[a._v("点进去重温一遍：[干货👍]从详细操作js数组到浅析v8中array.js")]),a._v(" "),e("p",[a._v("map接受两个参数，一个callback，一个this，即调用函数时this指向，其中callback回调函数是三个参数，一个currentValue，index，array；")]),a._v(" "),e("p",[a._v("parseInt接受两个参数：string,radix(基数)")]),a._v(" "),e("p",[a._v("返回NaN有两种情况")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("radix")]),a._v(" 小于 "),e("code",[a._v("2")]),a._v(" 或大于 "),e("code",[a._v("36")]),a._v(" ，或")]),a._v(" "),e("li",[a._v("第一个非空格字符不能转换为数字。")]),a._v(" "),e("li",[a._v("当radix是0或者undefined时，又是特殊情况，具体异步MDN")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("parseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n")])])]),e("p",[a._v("两者结合的话，结果自然很明显，[1,NaN,NaN]")]),a._v(" "),e("h3",{attrs:{id:"math-min-为什么比-math-max-大"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#math-min-为什么比-math-max-大"}},[a._v("#")]),a._v(" Math.min() 为什么比 Math.max() 大？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  Math.min() < Math.max() // false\n")])])]),e("p",[a._v("按照常规思路的话，应该是true，毕竟最小值应该小于最大值，但是实际情况是false")]),a._v(" "),e("p",[a._v("原因：")]),a._v(" "),e("ul",[e("li",[a._v("Math.min 的参数是 0 个或者多个。如果是多个参数很容易理解，返回参数中最小的。")]),a._v(" "),e("li",[a._v("如果是0个参数，或者没有参数，则返回 "),e("strong",[a._v("Infinity")]),a._v("。")]),a._v(" "),e("li",[a._v("而 Math.max() 没有传递参数时返回的是 -Infinity。")])]),a._v(" "),e("p",[a._v("要是面试官问这个问题，额。。。。")]),a._v(" "),e("h3",{attrs:{id:"concat-1-2-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#concat-1-2-3"}},[a._v("#")]),a._v(" [].concat[1,2,3]")]),a._v(" "),e("p",[a._v("输出是什么?注意不是[].concat([1,2,3])")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// [1,2,3]\n\n// Uncaught SyntaxError: ....\n\n// undefined\n")])])]),e("p",[a._v("答案是undefined，原因是什么呢？")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("第一步计算[].concat,结果是Array.prototype.concat")])]),a._v(" "),e("li",[e("p",[a._v("第二步执行一个逗号操作符，逗号操作符对它的每个操作对象求值（从左至右），然后返回最后一个操作对象的值。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(">1,2,3\n返回3\n")])])])]),a._v(" "),e("li",[e("p",[a._v("第三步执行一个数组访问运算或属性访问运算")])])]),a._v(" "),e("p",[a._v("所以上面[].concat[1,2,3] 等价于Array.prototype.concat[3]")]),a._v(" "),e("p",[a._v("那么结果自然就是 "),e("code",[a._v("undefined")]),a._v("。")]),a._v(" "),e("h3",{attrs:{id:"_1-2-nan-3-indexof-nan"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-nan-3-indexof-nan"}},[a._v("#")]),a._v(" [1,2,NaN,3].indexOf(NaN)")]),a._v(" "),e("p",[a._v("//2 or -1")]),a._v(" "),e("ul",[e("li",[a._v("indexOf方法会进行严格相等判断")]),a._v(" "),e("li",[a._v("NaN !== NaN")])]),a._v(" "),e("p",[a._v("怎么办呢？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let realIsNaN = value => typeof value === 'number' && isNaN(value);\n")])])]),e("p",[a._v("先要判断类型，是因为字符串转换会先转换成数字，转换失败为 NaN。所以和 NaN 相等。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("isNaN('jjjj') —> true\n")])])]),e("p",[a._v("第二种方法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let realIsNaN = value => value !== value;\n")])])]),e("h3",{attrs:{id:"number-isfinite-isfinite"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#number-isfinite-isfinite"}},[a._v("#")]),a._v(" Number.isFinite & isFinite")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Number.isFinite('0') === isFinite('0')\n\nNumber.isFinite(0) === isFinite('0')\n")])])]),e("p",[a._v("打印结果是什么，能不能具体说一说？")]),a._v(" "),e("blockquote",[e("p",[a._v("Number.isFinite()检测有穷性的值，唯一和全局isFinite()函数相比，这个方法不会强制将一个非数值的参数转换成数值，这就意味着，只有数值类型的值，且是有穷的（finite），才返回 "),e("code",[a._v("true")]),a._v("。")])]),a._v(" "),e("p",[a._v("自然答案就是 false,true")]),a._v(" "),e("h3",{attrs:{id:"一道容易被人轻视的面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一道容易被人轻视的面试题"}},[a._v("#")]),a._v(" 一道容易被人轻视的面试题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function Foo() {\n    getName = function () { alert (1); };\n    return this;\n}\nFoo.getName = function () { alert (2);};\nFoo.prototype.getName = function () { alert (3);};\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);}\n\n//请写出以下输出结果：\nFoo.getName();\ngetName();\nFoo().getName();\ngetName();\nnew Foo.getName();\nnew Foo().getName();\nnew new Foo().getName();\n")])])]),e("h3",{attrs:{id:"push方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#push方法"}},[a._v("#")]),a._v(" push方法")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let newList = [1,2,3].push(4)\nconsole.log(newList.push(4))\n")])])]),e("p",[a._v("认为输出什么？")]),a._v(" "),e("p",[a._v("// Error")]),a._v(" "),e("p",[a._v("原因在于Array.prototype.push()返回的是新数组的长度，所以呢4.push(5)自然Error")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"自动分号插入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动分号插入"}},[a._v("#")]),a._v(" 自动分号插入")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function foo1()\n{\n return {\n     bar: "hello"\n };\n}\n\nfunction foo2()\n{\n return\n {\n     bar: "hello"\n };\n}\nvar a=foo1();\nvar b=foo2();\nconsole.log(a) //Object {bar: "hello"}\nconsole.log(b) //underfind\n//仔细看就知道了\n// 会在第10行加入一个`;`\n')])])]),e("p",[a._v("会在第10行自动加一个分号; 所以返回的就是undefined")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"let-var"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#let-var"}},[a._v("#")]),a._v(" let var")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function foo() {\nlet a = b = 0;\na++;\nreturn a;\n}\nfoo();\ntypeof a; // => ???\ntypeof b; // => ???\n")])])]),e("p",[a._v("上面的let a = b = 0; 等价于 window.b  = 0, let a = b;")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"眼力题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#眼力题"}},[a._v("#")]),a._v(" 眼力题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const length = 4;\nconst numbers = [];\nfor (var i = 0; i < length; i++);{\n  numbers.push(i + 1);\n}\n\nnumbers; // => ???\n")])])]),e("p",[a._v("唯一需要注意的就是"),e("code",[a._v("for语句")]),a._v("后面带了"),e("code",[a._v(";")]),a._v("沙雕题")]),a._v(" "),e("p",[a._v("加了"),e("code",[a._v(";")]),a._v("，会认为for执行完，所以指定的都是空语句，最后numbers为[5]")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"获取字符串中特定索引字符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取字符串中特定索引字符"}},[a._v("#")]),a._v(" 获取字符串中特定索引字符")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log('Hello World'[4])\n")])])]),e("p",[a._v("使用的就是方括号表示法获取字符串特定索引的字符，值得注意的是，IE7低版本使用的是charAt()")]),a._v(" "),e("p",[a._v("所以这题输出o")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")]),a._v(" !==")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const name = 'TianTianUp'\nconsole.log(!typeof name === 'string')\nconsole.log(!typeof name === 'object')\n")])])]),e("p",[a._v("typeof name 返回的是 ’string‘, 字符串’string‘是一个truthy值。因此！typeof name 返回一个布尔值false。所以")]),a._v(" "),e("p",[a._v("false === ’string'")]),a._v(" "),e("p",[a._v("和 false === ’object‘返回false")]),a._v(" "),e("p",[a._v("(检测一个类型的值话，我们应该使用 !==而不是!typeof)")]),a._v(" "),e("hr"),a._v(" "),e("h3",{attrs:{id:"foreach"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#foreach"}},[a._v("#")]),a._v(" forEach")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const nums = [1, 2, 3, 4, 5, 6];\nlet firstEven;\nnums.forEach(n => {\n  if (n % 2 ===0 ) {\n    firstEven = n;\n    return n;\n  }\n});\nconsole.log(firstEven);\n")])])]),e("p",[a._v("唯一需要注意的就是forEach源码是怎么写的，看过源码的都知道，forEach使用return是不能中止循环的，或者说每一次调用callback函数，终止的是当前的一次，而不是整个循环。")]),a._v(" "),e("p",[a._v("结果自然就是6")])])}),[],!1,null,null,null);e.default=s.exports}}]);