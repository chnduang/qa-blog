(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{430:function(t,e,a){"use strict";a.r(e);var n=a(4),s=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"新出炉大厂面试题100道整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新出炉大厂面试题100道整理"}},[t._v("#")]),t._v(" 新出炉大厂面试题100道整理")]),t._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5MjMxMzY5Mw==&action=getalbum&album_id=1719758398499454985&scene=173&from_msgid=2247484107&from_itemidx=1&count=3&nolastread=1#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5MjMxMzY5Mw==&action=getalbum&album_id=1719758398499454985&scene=173&from_msgid=2247484107&from_itemidx=1&count=3&nolastread=1#wechat_redirect"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"html篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html篇"}},[t._v("#")]),t._v(" html篇")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdyL62HppibhdeZqQrLxjwoNibpV9OFianFsXTsm9B7fKHfias64aUHT6lddtjhlytRX0ic01GpULOlibmFw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题一-meta标签常用属性值的写法和作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题一-meta标签常用属性值的写法和作用"}},[t._v("#")]),t._v(" . 问题一:Meta标签常用属性值的写法和作用")]),t._v(" "),e("p",[t._v("答：\nmeta 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。")]),t._v(" "),e("p",[t._v("必要属性")]),t._v(" "),e("p",[t._v("name:属性名\ncontent:属性内容\ncharset: charset为HTML5中新增的，用来声明字符编码;\nhttp-equiv:属性在HTML4中有很多值，在HTML5中只有refresh、default-style、content-type可用")]),t._v(" "),e("p",[t._v("name的值和说明")]),t._v(" "),e("p",[t._v("application name   当前页所属Web应用系统的名称\nkeywords       描述网站内容的关键词,以逗号隔开，用于SEO搜索\ndescription       当前页的说明\nauthor         当前页的作者名\ncopyright       版权信息\nrenderer       renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面\nviewreport       它提供有关视口初始大小的提示，仅供移动设备使用")]),t._v(" "),e("p",[e("strong",[t._v("viewreport")]),t._v("\nmeta标签的name属性值为viewreport时的视口的大小")]),t._v(" "),e("p",[t._v("1.content内容为空时，默认视口宽度为980\n2.content设置width，不设置initail-scale时，视口宽度为设置的width值\n3.content不设置width，只设置initail-scale时，是可以根据initail-scale的值计算出视口的宽度\ninitail-scale = 屏幕宽度 / 视口宽度\n4.content同时设置width和initail-scale时，视口宽度为width的值，页面显示按照initail-scale比率进行缩放\n5.一般都是进行如下设置，来实现视口宽等于设备宽，布局完成后屏幕显示也不进行缩放")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta name="viewport" content="width=device-width, initial-scale=1.0">\n')])])]),e("p",[e("strong",[t._v("声明字符编码")]),t._v("\ncharset属性为HTML5新增的属性，用于声明字符编码,以下两种写法效果一样")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta charset="utf-8"> //HTML5\n')])])]),e("p",[e("strong",[t._v("模拟http标头字段")])]),t._v(" "),e("p",[t._v("http-equiv属性与content属性结合使用, http-equiv属性为指定所要模拟的标头字段的名称，content属性用来提供值。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="参数" content="具体的描述">\n')])])]),e("p",[t._v("content-Type 声明网页字符编码:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="content-Type" content="text/html charset=UTF-8">\n')])])]),e("p",[t._v("refresh 指定一个时间间隔(以秒为单位),在此时间过去之后从服务器重新载入当前页面,也可以另外指定一个页面.")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="refresh" content="2;URL=http://www.baidu.com">//2秒后在当前页跳转到百度\n')])])]),e("p",[t._v("X-UA-Compatible 浏览器采取何种版本渲染当前页面")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> //指定IE和Chrome使用最新版本渲染当前页面\n')])])]),e("p",[t._v("expires 用于设定网页的到期时间，过期后网页必须到服务器上重新传输")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="expires" content="Sunday 22 July 2016 16:30 GMT">\n')])])]),e("p",[t._v("catch-control 用于指定所有缓存机制在整个请求/响应链中必须服从的指令")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<meta http-equiv="cache-control" content="no-cache">\n')])])]),e("h2",{attrs:{id:"js篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js篇"}},[t._v("#")]),t._v(" js篇")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdyUum0Pw5GMxyk5Fv7DiciavFwXo3QDWSreE3gE0nsd3K8vET6ia73QMHtdTCzWOmV6vNnOEicVedYuNg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题1-给对象加上iterator接口-使之能被-for-of遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题1-给对象加上iterator接口-使之能被-for-of遍历"}},[t._v("#")]),t._v(" . 问题1: 给对象加上iterator接口,使之能被 for of遍历")]),t._v(" "),e("p",[t._v("ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数")]),t._v(" "),e("p",[t._v("因为object 没有 Symbol.iterator 属性，所以不能被 for of 遍历。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const text = {\n   a: 1,\n   b: 2,\n   c:3\n}\nfor(let i of text){\n    console.log(i) //报错：Uncaught TypeError: text is not iterable\n}\n")])])]),e("p",[t._v("所以，object想要被 for … of遍历 ，必须在原来的基础上加上 Symbol.iterator 接口属性。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const text = {\n   a: 1,\n   b: 2,\n   c:3\n}\ntext[Symbol.iterator] = function (){\n    const _this = this\n    return {\n        index:-1,\n        next(){\n            const arr = Object.keys( _this )\n            if(this.index < arr.length){\n                this.index++\n                return {\n                    value:_this[arr[this.index]],\n                    done:false\n                }\n            }else{\n                return {\n                    value:undefined,\n                    done:true\n                }\n            }\n        }\n    }\n}\n\nfor(let i of text){\n    console.log(i) // 1 2 3 undefined\n}\n")])])]),e("h3",{attrs:{id:"问题2-统计按钮一秒钟点击次数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题2-统计按钮一秒钟点击次数"}},[t._v("#")]),t._v(" . 问题2:统计按钮一秒钟点击次数？")]),t._v(" "),e("p",[t._v("这道题是变相考对防抖函数+闭包的理解")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<script>\n\nconst button = document.getElementById('button')\nfunction debounce(fn, time) {\n    let number = 0 , timer  = null\n    return function(...arg) { \n        fn.apply(this, arg)\n        number++\n        if (timer) return\n        timer = setTimeout(() => {\n           console.log( '点击'+ number + '次' )\n           number = 0\n           timer = null\n        }, time)\n    }\n}\nbutton.onclick = debounce(()=>{\n    console.log(1111)\n},1000)\n\n<\/script>\n")])])]),e("p",[t._v("效果如下")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题3-单页面应用路由的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题3-单页面应用路由的原理"}},[t._v("#")]),t._v(" . 问题3:单页面应用路由的原理")]),t._v(" "),e("p",[t._v("无论我们用vue还是react构建单页面应用，都离不开路由的概念，路由跳转监听url改变，根据路由的改变来决定渲染的页面。")]),t._v(" "),e("h4",{attrs:{id:"hash模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hash模式"}},[t._v("#")]),t._v(" hash模式")]),t._v(" "),e("p",[e("strong",[t._v("改变路由")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('const path = "home"\nwindow.location.hash = path\n')])])]),e("p",[e("strong",[t._v("监听路由")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("window.addEventListener('hashchange',function(e){\n  //路由发生改变时切换渲染组件...\n});\n")])])]),e("h4",{attrs:{id:"histroy模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#histroy模式"}},[t._v("#")]),t._v(" histroy模式")]),t._v(" "),e("p",[e("strong",[t._v("改变路由")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var path = \"home\"\nhistory.pushState(null,null,'?='+path);\n")])])]),e("p",[e("strong",[t._v("监听路由")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("window.addEventListener('popstate',function(e){\n   //路由发生改变时切换渲染组件...\n})\n")])])]),e("h3",{attrs:{id:"问题4-如下打印结果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题4-如下打印结果"}},[t._v("#")]),t._v(" . 问题4:如下打印结果")]),t._v(" "),e("p",[t._v("执行如下代码，回发生什么？")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function fn1(){\n    console.log(a)\n}\nvar a = 1\n\nfunction fn2(){\n    console.log(a)\n    let a = 2;\n    console.log(a)\n    fn1()\n}\n\nfn2()\n")])])]),e("p",[t._v("结果：//Uncaught ReferenceError: Cannot access 'a' before initialization")]),t._v(" "),e("p",[e("strong",[t._v("let 暂时性死区")])]),t._v(" "),e("p",[t._v("let/const是使用区块作用域；var是使用函数作用域")]),t._v(" "),e("p",[t._v("在let/const声明之前就访问对应的变量与常量，会抛出ReferenceError错误；但在var声明之前就访问对应的变量，则会得到undefined")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("console.log(a) // undefined\nconsole.log(b) // causes ReferenceError: b is not defined\nvar a = 1\nlet b = 2 \n")])])]),e("h3",{attrs:{id:"问题5-apply和call-bind的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题5-apply和call-bind的区别"}},[t._v("#")]),t._v(" . 问题5:apply和call,bind的区别")]),t._v(" "),e("p",[e("strong",[t._v("apply，call和bind都是 用来改变this的指向")])]),t._v(" "),e("p",[e("strong",[t._v("apply和call会让当前函数立即执行，而bind会返回一个函数，后续需要的时候再调用执行")])]),t._v(" "),e("p",[e("strong",[t._v("apply，call的区别实参数不同")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const foot ={\n    apple:'苹果'\n}\nfunction eat(a,b){\n   console.log(a,b,this)\n}\n\nconst bindEat = eat.bind(foot)\n\neat(1,2) // 1 2 Window\n\nbindEat(1,2) //1 2  foot \n\neat.call(foot,1,2) //1 2  foot\n\n/* apply参数已数组形式传递  */\neat.apply(foot,[1,2]) //1 2  foot\n")])])]),e("h3",{attrs:{id:"问题6-开发过程中遇到的内存泄露情况-如何解决的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题6-开发过程中遇到的内存泄露情况-如何解决的"}},[t._v("#")]),t._v(" . 问题6:开发过程中遇到的内存泄露情况，如何解决的?")]),t._v(" "),e("p",[t._v("javascript内存泄漏几种情况")]),t._v(" "),e("p",[e("strong",[t._v("1 意外的全局变量")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function foo(arg) { \n    bar = "this is a hidden global variable"; \n}\n')])])]),e("p",[t._v("另一种意外的全局变量可能由 this 创建：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function foo() { \n    this.variable = "potential accidental global"; \n} \n// Foo 调用自己，this 指向了全局对象（window） \n// 而不是 undefined \nfoo();\n')])])]),e("p",[t._v("尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于 临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓 存内容无法被回收。")]),t._v(" "),e("p",[e("strong",[t._v("2被遗忘的计时器或回调函数")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var someResource = getData(); \nsetInterval(function() { \n    var node = document.getElementById('Node'); \n    if(node) { \n        // 处理 node 和 someResource \n        node.innerHTML = JSON.stringify(someResource)); \n    } \n}, 1000);\n")])])]),e("p",[t._v("与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。")]),t._v(" "),e("p",[e("strong",[t._v("3脱离 DOM 的引用")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var elements = { \n    button: document.getElementById('button'), \n    image: document.getElementById('image'), \n    text: document.getElementById('text') \n}; \n\nfunction doStuff() { \n    image.src = 'http://some.url/image'; \n    button.click(); \n    console.log(text.innerHTML); \n    // 更多逻辑 \n} \n\nfunction removeButton() { \n    // 按钮是 body 的后代元素 \n    document.body.removeChild(document.getElementById('button')); \n\n    // 此时，仍旧存在一个全局的 #button 的引用 \n    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 \n}\n")])])]),e("p",[e("strong",[t._v("4 闭包的错误使用")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var theThing = null; \nvar replaceThing = function () { \n  var originalThing = theThing; \n  var unused = function () { \n    if (originalThing) \n      console.log(\"hi\"); \n  }; \n  theThing = { \n    longStr: new Array(1000000).join('*'), \n    someMethod: function () { \n      console.log(someMessage); \n    } \n  }; \n}; \nsetInterval(replaceThing, 1000); \n")])])]),e("p",[t._v("每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄露。")]),t._v(" "),e("p",[e("strong",[t._v("解决内存泄漏方式")])]),t._v(" "),e("p",[t._v("1 使用严格模式，合理声明变量。使用严格模式可以避免第一种情况的发生。")]),t._v(" "),e("p",[t._v("2 及时清理定时器，延时器，对于不需要的定时器和延时器，一定要及时清除。")]),t._v(" "),e("p",[t._v("3 合理应用闭包，合理的应用闭包，避免闭包函数反复执行导致内存无法及时释放。")]),t._v(" "),e("h3",{attrs:{id:"问题7-介绍一下proto和prototype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题7-介绍一下proto和prototype"}},[t._v("#")]),t._v(" . 问题7:介绍一下"),e("strong",[t._v("proto")]),t._v("和prototype")]),t._v(" "),e("p",[e("strong",[t._v("proto")]),t._v("和prototype 是我们在平时工作中容易忽略的问题，对象原型 和 原型链 的概念也容易混淆。")]),t._v(" "),e("p",[t._v("**"),e("em",[t._v("*proto*"),e("em",[t._v("是每个对象都有的属性")])]),t._v(" ，在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。")]),t._v(" "),e("p",[e("strong",[t._v("prototypee是函数才有的属性")]),t._v("，方法(Function)方法这个特殊的对象，除了和其他对象一样有上述proto属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法就是该实例的"),e("strong",[t._v("proto")]),t._v("。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" let a = function (){\n\n }\n a.prototype.eat = function(){ console.log(111) }\n const na = new a()\n console.log( na.__proto__ === a.prototype ) // ture\n")])])]),e("h3",{attrs:{id:"问题8-说一下arguments对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题8-说一下arguments对象"}},[t._v("#")]),t._v(" . 问题8:说一下arguments对象")]),t._v(" "),e("p",[t._v("在函数调用的时候，浏览器每次都会传递进arguments对象,arguments 对象实际上是所在函数的一个内置类数组对象，arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的Array.typeof参数返回 'object'。")]),t._v(" "),e("p",[t._v("属性\n"),e("strong",[t._v("arguments.callee")]),t._v("指向参数所属的当前执行的函数。指向调用当前函数的函数。\n"),e("strong",[t._v("arguments.length")]),t._v("传递给函数的参数数量。\n**arguments[@@iterator]**返回一个新的Array 迭代器 对象，该对象包含参数中每个索引的值。")]),t._v(" "),e("h3",{attrs:{id:"问题9-怎么实现一个队列的数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题9-怎么实现一个队列的数据结构"}},[t._v("#")]),t._v(" . 问题9:怎么实现一个队列的数据结构？")]),t._v(" "),e("p",[e("strong",[t._v("介绍")]),t._v("\n队列也是一种线性表。它允许在表的一端插入数据，在另一端删除元素。插入元素的这一端称之为队尾。删除元素的这一端我们称之为队首。")]),t._v(" "),e("p",[e("strong",[t._v("特性")]),t._v("\n1 在队尾插入元素，在队首删除元素。\n2 FIFO（先进先出），就向排队取票一样。")]),t._v(" "),e("p",[e("strong",[t._v("简单js实现")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Queue {\n    constructor(){\n        this.queue = []\n    }\n    /* 进入队列 */\n    enqueue(item){\n        this.queue.push(item)\n    }\n    /* 移除队列 */\n    dequeue(){\n        this.queue.shift()\n    }\n    /* 获取队列长度 */\n    size(){\n        return this.queue.length\n    }\n    /* 判断是否为空 */\n}\n")])])]),e("h2",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" css")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题一-什么是vw-vh布局-有哪些有优点-有哪些缺陷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题一-什么是vw-vh布局-有哪些有优点-有哪些缺陷"}},[t._v("#")]),t._v(" . 问题一：什么是vw+vh布局？有哪些有优点？有哪些缺陷？")]),t._v(" "),e("p",[t._v("解答：")]),t._v(" "),e("p",[e("strong",[t._v("1什么是什么是vw/vh")])]),t._v(" "),e("p",[t._v('css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下：\n单位含义vw相对于视窗的宽度，视窗宽度是100vwvh相对于视窗的高度，视窗高度是100vhvminvw和vh中的较小值vmaxvw和vh中的较大值；\n这里我们发现视窗宽高都是100vw／100vh，那么vw或者vh，下简称vw，很类似百分比单位。vw和%的区别为：\n单位含义%大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)vw/vh相对于视窗的尺寸\n从对比中我们可以发现，vw单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的vw更像"理想的百分比单位"。任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。')]),t._v(" "),e("p",[e("strong",[t._v("2vw单位换算")])]),t._v(" "),e("p",[t._v("同样的，如果要将px换算成vw单位，很简单，只要确定视图的窗口大小（布局视口），如果我们将布局视口设置成分辨率大小，比如对于iphone6/7 375*667的分辨率，那么px可以通过如下方式换算成vw：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1px = （1/375）*100 vw\n")])])]),e("p",[e("strong",[t._v("3缺陷")])]),t._v(" "),e("p",[t._v("1 绝大多数的浏览器支持vw单位，但是ie9-11不支持vmin和vmax，考虑到vmin和vmax单位不常用，vw单位在绝大部分高版本浏览器内的支持性很好，但是opera浏览器整体不支持vw单位，如果需要兼容opera浏览器的布局，不推荐使用vw。")]),t._v(" "),e("p",[t._v("2 由于是相对手机窗口，针对不同的手机视图大小不同，所以需要对单位进行换算处理。")]),t._v(" "),e("h3",{attrs:{id:"问题二-什么是rem布局-rem布局的缺陷。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题二-什么是rem布局-rem布局的缺陷。"}},[t._v("#")]),t._v(" . 问题二:什么是rem布局？rem布局的缺陷。")]),t._v(" "),e("p",[t._v("答：")]),t._v(" "),e("p",[e("strong",[t._v("rem布局")])]),t._v(" "),e("p",[t._v("rem是一个灵活的、可扩展的单位，由浏览器转化像素并显示。与em单位不同，rem单位无论嵌套层级如何，都只相对于浏览器的根元素（HTML元素）的font-size。默认情况下，html元素的font-size为16px，所以：\n1 rem = 12px\n为了计算方便，通常可以将html的font-size设置成：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("html{ font-size: 62.5% }\n")])])]),e("p",[t._v("这种情况下：\n1 rem = 10px\nrem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。")]),t._v(" "),e("p",[e("strong",[t._v("rem布局缺陷")])]),t._v(" "),e("p",[t._v("1 在响应式布局中，必须通过js来动态控制根元素font-size的大小。\n1 css样式和js代码有一定的耦合性。且必须将改变font-size的代码放在css样式之前")]),t._v(" "),e("h3",{attrs:{id:"问题三-怎么让chrome支持小于12px-的文字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题三-怎么让chrome支持小于12px-的文字"}},[t._v("#")]),t._v(" . 问题三:怎么让Chrome支持小于12px 的文字")]),t._v(" "),e("p",[t._v("谷歌浏览器默认最小字体为12px，若想让chorme支持12px字体，只需要用css3属性transform就可以")]),t._v(" "),e("p",[t._v("🌰例子：在谷歌浏览器写出10px字体")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("transform:scale(0.5);\nfont-size:20px;\n")])])]),e("p",[t._v("搞定收工～～～")]),t._v(" "),e("h3",{attrs:{id:"问题四-透明度opacity和rgba的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题四-透明度opacity和rgba的区别"}},[t._v("#")]),t._v(" . 问题四：透明度opacity和rgba的区别")]),t._v(" "),e("p",[e("strong",[t._v("opacity")])]),t._v(" "),e("p",[t._v("取值在0到1之间，0表示完全透明，1表示完全不透明。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(".box{opacity: 0.5;}\n")])])]),e("p",[e("strong",[t._v("rgba")])]),t._v(" "),e("p",[t._v("rgba中的R表示红色，G表示绿色，B表示蓝色，三种颜色的值都可以是正整数或百分数。A表示Alpha透明度。取值0~1之间，类似opacity。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(".box{background: rgba(255,0,0,0.5);}\n")])])]),e("p",[e("strong",[t._v("rgba和opacity的区别")]),t._v("\nrgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。")]),t._v(" "),e("h3",{attrs:{id:"问题五-position的属性值有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题五-position的属性值有哪些"}},[t._v("#")]),t._v(" . 问题五:position的属性值有哪些？")]),t._v(" "),e("p",[e("strong",[t._v("absolute")]),e("br"),t._v("\n生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。")]),t._v(" "),e("p",[t._v('元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。')]),t._v(" "),e("p",[e("strong",[t._v("fixed")]),e("br"),t._v("\n生成绝对定位的元素，相对于浏览器窗口进行定位。")]),t._v(" "),e("p",[t._v('元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。')]),t._v(" "),e("p",[e("strong",[t._v("relative")]),e("br"),t._v('\n生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。')]),t._v(" "),e("p",[e("strong",[t._v("static")]),t._v("\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\n"),e("strong",[t._v("inherit")]),e("br"),t._v("\n规定应该从父元素继承 position 属性的值。")]),t._v(" "),e("h3",{attrs:{id:"问题六-display的属性值有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题六-display的属性值有哪些"}},[t._v("#")]),t._v(" . 问题六:display的属性值有哪些？")]),t._v(" "),e("p",[t._v("none（元素不会被显示）;")]),t._v(" "),e("p",[t._v("block（元素将显示为块级元素，元素前后会带有换行符）;")]),t._v(" "),e("p",[t._v("inline（元素会被显示为内联元素，元素前后没有换行符）;")]),t._v(" "),e("p",[t._v("inline-block（行内块元素。CSS2.1新增的值）;")]),t._v(" "),e("p",[t._v("table（元素会作为块级表格来显示，类似table，表格前后带有换行符）;")]),t._v(" "),e("p",[t._v("table-row（元素会作为一个表格行显示，类似tr）;")]),t._v(" "),e("p",[t._v("table-cell（元素会作为一个表格单元格显示，类似td和th）")]),t._v(" "),e("p",[t._v("flex 弹性盒结构")]),t._v(" "),e("p",[t._v("gird 网格结构")]),t._v(" "),e("h3",{attrs:{id:"问题七-垂直水平居中的方案有哪些-尽量说全面一些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题七-垂直水平居中的方案有哪些-尽量说全面一些"}},[t._v("#")]),t._v(" . 问题七:垂直水平居中的方案有哪些（尽量说全面一些）")]),t._v(" "),e("p",[e("strong",[t._v("position absolute 50% + 负margin -50%")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(".container {\n    position: relative;\n}\n.box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50%;\n    margin-left: -50%;\n}\n")])])]),e("p",[e("strong",[t._v("position absolute  50% + transform -50%")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(".container {\n    position: relative;\n}\n.box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n")])])]),e("p",[e("strong",[t._v("css-table")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/* 此处引用上面的公共代码 */\n.container {\n    display: table-cell;\n    text-align: center;\n    vertical-align: middle;\n}\n.box {\n    display: inline-block;\n}\n")])])]),e("p",[e("strong",[t._v("flex")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/* 此处引用上面的公共代码 */\n.container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.box-center {\n    text-align: center;\n}\n")])])]),e("p",[e("strong",[t._v("grid")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/* 此处引用上面的公共代码 */\n.container {\n    display: grid;\n    justify-items: center;\n    align-items: center;\n}\n.box-center {\n    text-align: center;\n}\n")])])]),e("h2",{attrs:{id:"vue-篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-篇"}},[t._v("#")]),t._v(" vue 篇")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题1-vue各个生命周期及其作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题1-vue各个生命周期及其作用"}},[t._v("#")]),t._v(" . 问题1:vue各个生命周期及其作用")]),t._v(" "),e("p",[t._v("1.初始化")]),t._v(" "),e("p",[e("strong",[t._v("beforeCreate")]),t._v("：大vue已经初始化，只是数据初始化与事件系统构建尚未形成，不能获取DOM节点（没有data，没有el）\n使用场景：因为此时data和methods都拿不到，所以通常在实例以外使用。\n"),e("strong",[t._v("created")]),t._v("：实例已经创建，仍然不能获取DOM节点（有data，没有el）\n使用场景：模板渲染成html前调用，此时可以获取data和methods， 可以初始化进行数据请求，得到渲染数据，，异步操作可以放在这里\n2 挂载\n"),e("strong",[t._v("beforeMount")]),t._v("是个过渡阶段，此时依然获取不到具体的DOM节点，但是vue挂载的根节点已经创建（有data，有el）\n"),e("strong",[t._v("mounted")]),t._v("：组件挂载完成，数据和DOM都已经被渲染出来了\n使用场景：模板渲染成html后调用，通常是初始化页面完成后再对数据和DOM做一些操作，需要操作DOM的方法可以放在这里\n3.更新\n"),e("strong",[t._v("beforeUpdate")]),t._v("：检测到数据更新时，但在DOM更新前执行\n"),e("strong",[t._v("updated")]),t._v("：更新结束后执行\n使用场景：需要对数据更新做统一处理的；如果需要区分不同的数据更新操作可以使用$nextTick\n4.销毁\n"),e("strong",[t._v("beforeDestroy")]),t._v("：当要销毁vue实例时，在销毁前执行\n"),e("strong",[t._v("destroyed")]),t._v("：销毁vue实例时执行")]),t._v(" "),e("p",[t._v("父子组件mounted和destroyed顺序")]),t._v(" "),e("p",[t._v("beforeMount执行顺序 先父后子")]),t._v(" "),e("p",[t._v("mounted执行顺序,先子后父")]),t._v(" "),e("p",[t._v("beforeDestroy 执行顺序，先父后子")]),t._v(" "),e("p",[t._v("destroyed 执行顺序 ， 先子后父")]),t._v(" "),e("h3",{attrs:{id:"问题2-vue3的双向绑定原理-与vue2-0比起来有那些优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题2-vue3的双向绑定原理-与vue2-0比起来有那些优势"}},[t._v("#")]),t._v(" . 问题2:vue3的双向绑定原理,与vue2.0比起来有那些优势？")]),t._v(" "),e("p",[t._v("vue3.0 的数据绑定原理 proxy 对象\nvue3.0 于 Proxy 的 observer 实现， 代替了Vue 2 系列中基于 Object.defineProperty 做为响应式原理")]),t._v(" "),e("p",[t._v("感兴趣的同学可以看一下笔者的vue3.0响应式原理详解")]),t._v(" "),e("p",[t._v("传送门：vue3.0 响应式原理(超详细)")]),t._v(" "),e("p",[t._v("优势：\n1 对属性的添加、删除动作的监测；\n2 对数组基于下标的修改、对于 .length 修改的监测；\n3 对 Map、Set、WeakMap 和 WeakSet 的支持；；\n4 vue3 对依赖收集用的是weaMap，WeakSet，保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n5 vue2.0 初始化data时候，对于对象等引用数据类型，进行了递归处理，也就是对于一些挂载在data上属性,但是并没有用到的属性，也同样做了响应式处理，而vue3.0之后访问到父级属性之后，在进行下一层track,也就是说初始化data时候无需把大量性能浪费在递归上。")]),t._v(" "),e("h3",{attrs:{id:"问题3-vue路由卫士"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题3-vue路由卫士"}},[t._v("#")]),t._v(" . 问题3:vue路由卫士？")]),t._v(" "),e("p",[t._v("vue中路由守卫一共有三种，一个全局路由守卫，一个是组件内路由守卫，一个是router独享守卫。")]),t._v(" "),e("p",[e("strong",[t._v("一、全局路由守卫")])]),t._v(" "),e("p",[t._v("只要全局路由变化，就会触发全局的路由守卫。\n全局路由守卫有个两个：一个是全局前置守卫，一个是全局后置守卫。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("router.beforeEach((to, from, next) => {\n    console.log(to) => // 到哪个页面去？\n    console.log(from) => // 从哪个页面来？\n    next() => // 一个回调函数\n}\nrouter.afterEach（to，from） = {}\n")])])]),e("p",[t._v("next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址,next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项.")]),t._v(" "),e("p",[e("strong",[t._v("二、组件路由守卫")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 跟methods: {}等同级别书写，组件路由守卫是写在每个单独的vue文件里面的路由守卫\nbeforeRouteEnter (to, from, next) {\n    // 注意，在路由进入之前，组件实例还未渲染，所以无法获取this实例，只能通过vm来访问组件实例\n    next(vm => {})\n}\nbeforeRouteUpdate (to, from, next) {\n    // 同一页面，刷新不同数据时调用，\n}\nbeforeRouteLeave (to, from, next) {\n    // 离开当前路由页面时调用\n}\n")])])]),e("p",[e("strong",[t._v("三、路由独享守卫")]),t._v("\n路由独享守卫是在路由配置页面单独给路由配置的一个守卫")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export default new VueRouter({\n    routes: [\n        {\n            path: '/',\n            name: 'home',\n            component: 'Home',\n            beforeEnter: (to, from, next) => {\n               // ...\n            }\n        }\n    ]\n})\n")])])]),e("h3",{attrs:{id:"问题4-vue-中watch和computed区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题4-vue-中watch和computed区别"}},[t._v("#")]),t._v(" . 问题4:vue 中watch和computed区别？")]),t._v(" "),e("p",[t._v("watch侧重点是对数据更新所产生的依赖追踪，而computed侧重点是对数据的缓存与处理引用，这就是watch和computed本质的区别 ,computed可以看作一种特殊的data数据类型 ，它内部进行了二次依赖收集 ，第一次依赖收集是引用computed属性值，而进行的依赖收集 ，第二次是对computed内部是否关联data或者props的属性，而又进行的一次依赖收集。")]),t._v(" "),e("p",[t._v("下面我们按照vue3.0两个例子，来分别两者之前在流程上有什么区别。")]),t._v(" "),e("p",[e("strong",[t._v("watch")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<div id=\"app\">\n   <p>{{ count }}</p>\n   <button @input=\"add\" >add</button>\n</div>\n<script>\nconst { reactive, watch, toRefs } = Vue\nVue.createApp({\n  setup(){\n    const state = reactive({\n       count:1,\n    })\n    const add = () => state.count++\n    watch(state.count,(count, prevCount) => {\n       console.log('新的count=' , count )\n    })\n    return {\n      ...toRefs(state),\n      add\n    }\n  }\n}).mount('#app')\n<\/script>\n")])])]),e("p",[t._v("从上述例子我们看出，当点击add后count变化 ，而是 watch作用就是，追踪到count变化 ，而促使回调函数执行。我们用一张流程图来解析整个流程。")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("p",[e("strong",[t._v("computed")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<div id="app">\n   <p>{{ plusOne }}</p>\n   <button @input="add" >add</button>\n</div>\n\n<script>\nVue.createApp({\n  data: () => ({\n    number: 1\n  }),\n  computed: {\n    plusOne() {\n      return this.number + 1\n    }  \n  },\n  methods: {\n    add(){\n      this.number++\n    }\n  }\n}).mount(\'#app\')\n<\/script>\n')])])]),e("p",[t._v("当我们点击add改变的是number，但是引用过this.number的computed也更新了新的值 ，页面更新，我们可以看出 plusOne计算属性可以看作一个对number缓存的数据类型，data下的number收集了plusOne依赖项，同样plusOne也收集了"+t._s(t.plusOne)+"的依赖促使更新视图，我们用一张流程图来解析整个流程。")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("p",[t._v("如果想要看原理解析请看笔者的文章")]),t._v(" "),e("p",[t._v("传送门 vue3.0 watch 和 computed源码解析(举例图解)")]),t._v(" "),e("h3",{attrs:{id:"问题5-vue中data为什么要是个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题5-vue中data为什么要是个函数"}},[t._v("#")]),t._v(" . 问题5:vue中data为什么要是个函数？")]),t._v(" "),e("p",[t._v("vue中data必须是一个函数是和js本身特性有关。")]),t._v(" "),e("p",[t._v("我们做vue项目的时候，所有的vue组件都是基于大vue实例化的，我们可以用一个简单例子来解释一下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Vue(){\n\n}\nVue.prototype.data = {\n    name:'jack',\n    age:22,\n}\nvar componentA = new Vue();\nvar componentB = new Vue();\ncomponentA.data.age=55;\nconsole.log(componentA,componentB)\n")])])]),e("p",[t._v("此时，componentA 和 componentB data之间指向了同一个内存地址，age 都变成了 55， 导致了问题！\n接下来很好解释为什么 vue 组件需要 function 了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Vue(){\n this.data = this.data()\n}\nVue.prototype.data = function (){\n    return {\n    name:'jack',\n    age:22,\n}\n}\nvar componentA = new Vue();\nvar componentB = new Vue();\ncomponentA.data.age=55;\nconsole.log(componentA,componentB)\n")])])]),e("p",[t._v("componentA 和 componentB data之间相互独立, age 分别是 55 和 22\n"),e("strong",[t._v("当data是一个方法的时候，每一个实例化组件都会形成一个独立的data对象，相互之间没有影响。")])]),t._v(" "),e("h2",{attrs:{id:"react-篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-篇"}},[t._v("#")]),t._v(" react 篇")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题1-setstate是同步的还是异步的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题1-setstate是同步的还是异步的"}},[t._v("#")]),t._v(" . 问题1:setState是同步的还是异步的？")]),t._v(" "),e("p",[t._v("对于这个问题，笔者自己总结了一下：对于setState是同步还是异步，对于整个react代码执行上下文来说，"),e("strong",[t._v("setState是同步的")]),t._v("，但是setState触发以后，并不一定得到新的数据，这里有一个react有一个"),e("strong",[t._v("batchUpdate批量更新")]),t._v("的概念。")]),t._v(" "),e("p",[t._v("我们来看一个例子🌰：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Example extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      val: 0\n    };\n  }\n\n  componentDidMount() {\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);    // 第 1 次 log\n\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);    // 第 2 次 log\n\n    setTimeout(() => {\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);  // 第 3 次 log\n\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);  // 第 4 次 log\n    }, 0);\n  }\n\n  render() {\n    return null;\n  }\n};\n")])])]),e("p",[t._v("答案是：0 0 2 3")]),t._v(" "),e("p",[t._v("在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state 。")]),t._v(" "),e("h3",{attrs:{id:"问题2-介绍一下-react-hooks-api及其如何使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题2-介绍一下-react-hooks-api及其如何使用"}},[t._v("#")]),t._v(" . 问题2:介绍一下 react-hooks API及其如何使用？")]),t._v(" "),e("p",[t._v("usestate 无状态组件的state")]),t._v(" "),e("p",[t._v("useCallback,useMemo 性能优化利器.")]),t._v(" "),e("p",[t._v("useContext 可以使用操纵react context.")]),t._v(" "),e("p",[t._v("useEffect ，useLayoutEffect 副作用钩子 可以替代class声明组件中的声明周期 .useLayoutEffect 在浏览器渲染之前 ， effect在浏览器渲染之后")]),t._v(" "),e("p",[t._v("useReducer 功能可以参考redux")]),t._v(" "),e("p",[t._v("useRef 可以获取元素和组件实例，还可以缓存数据")]),t._v(" "),e("p",[t._v("详细的react-hooks使用可以戳👇")]),t._v(" "),e("p",[t._v("传送门：react-hooks如何使用？")]),t._v(" "),e("h2",{attrs:{id:"webpack篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack篇"}},[t._v("#")]),t._v(" webpack篇")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题一-webpack性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题一-webpack性能优化"}},[t._v("#")]),t._v(" . 问题一:webpack性能优化？")]),t._v(" "),e("p",[t._v("打包的时间和打包之后文件的体积是影响webpack性能的主要因素。所以我们可以从这两个方面入手，来优化webpack性能。")]),t._v(" "),e("p",[e("strong",[t._v("1合理使用loader")]),t._v("\n用 include 或 exclude 来帮我们避免不必要的转译，优化loader的管辖范围。")]),t._v(" "),e("p",[e("strong",[t._v("2缓存babel编译过的文件")])]),t._v(" "),e("p",[t._v("loader: 'babel-loader?cacheDirectory=true'\n如上，我们只需要为 loader 增加相应的参数设定。选择开启缓存将转译结果缓存至文件系统，可以提交babel-loader的工作效率。")]),t._v(" "),e("p",[e("strong",[t._v("3  DllPlugin类库引入")])]),t._v(" "),e("p",[t._v("DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。")]),t._v(" "),e("p",[e("strong",[t._v("4 happypack多进程编译")])]),t._v(" "),e("p",[t._v("我们都知道nodejs是单线程。无法一次性执行多个任务。这样会使得所有任务都排队执行。happypack可以根据cpu核数优势，建立子进程child_process,充分利用多核优势解决这个问题。提高了打包的效率。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const HappyPack = require('happypack')\n// 手动创建进程池\nconst happyThreadPool =  HappyPack.ThreadPool({ size: os.cpus().length })\nmodule.exports = {\n  module: {\n    rules: [\n      ...\n      {\n        test: /\\.js$/,\n        // 问号后面的查询参数指定了处理这类文件的HappyPack实例的名字\n        loader: 'happypack/loader?id=happyBabel',\n        ...\n      },\n    ],\n  },\n  plugins: [\n    ...\n    new HappyPack({\n      // 这个HappyPack的“名字”就叫做happyBabel，和楼上的查询参数遥相呼应\n      id: 'happyBabel',\n      // 指定进程池\n      threadPool: happyThreadPool,\n      loaders: ['babel-loader?cacheDirectory']\n    })\n  ],\n}\n")])])]),e("p",[t._v("`\nhappypack成功，启动了三个进程编译。加快了loader的加载速度。")]),t._v(" "),e("p",[e("strong",[t._v("5 scope Hoisting")])]),t._v(" "),e("p",[t._v("scope Hoisting的作用是分析模块之前的依赖关系 ， 把打包之后的公共模块合到同一个函数中去。它会代码体积更小，因为函数申明语句会产生大量代码；代码在运行时因为创建的函数作用域更少了，内存开销也随之变小。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');\n\nmodule.exports = {\n  resolve: {\n    // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件\n    mainFields: ['jsnext:main', 'browser', 'main']\n  },\n  plugins: [\n    // 开启 Scope Hoisting\n    new ModuleConcatenationPlugin(),\n  ],\n};\n")])])]),e("p",[e("strong",[t._v("6  tree Shaking 删除冗余代码")])]),t._v(" "),e("p",[t._v("Tree-Shaking可以通过分析出import/exports依赖关系。对于没有使用的代码。可以自动删除。这样就减少了项目的体积。")]),t._v(" "),e("p",[t._v("举个例子🌰：")]),t._v(" "),e("p",[t._v("import { a, b } from './pages'\na()\npages 文件里，我虽然导出了两个页面：\nexport const a = ()=>{ console.log(666) }\nexport const b = ()=>{ console.log(666) }\n所以打包的结果会保留这部分：\nexport const a = ()=>{ console.log(666) }\nb方法直接删掉，这就是 Tree-Shaking 帮我们做的事情。删掉了没有用到的代码。")]),t._v(" "),e("p",[e("strong",[t._v("7 按需加载")])]),t._v(" "),e("p",[t._v("像vue 和 react spa应用，首次加载的过程中，由于初始化要加载很多路由，加载很多组件页面。会导致 首屏时间 非常长。一定程度上会影响到用户体验。所以我们需要换一种按需加载的方式。一次只加载想要看到的内容")]),t._v(" "),e("p",[t._v("require.ensure 形式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const getComponent => (location, cb) {\n  require.ensure([], (require) => {\n    cb(null, require('../pages/AComponent').default)\n  }, 'a')\n}\n<Route path=\"/a\" getComponent={getComponent}>\n")])])]),e("p",[t._v("import形式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import B from '@/pages/business/b.vue'\n//按需加载变成了：\nconst B = () => import('@/pages/business/b.vue')\n")])])]),e("p",[e("strong",[t._v("8 按需引用")])]),t._v(" "),e("p",[t._v("不知道大家有没有体会到，当我们用antd等这种UI组件库的时候。明明只想要用其中的一两个组件，却要把整个组件库连同样式库一起引进来，就会造成打包后的体积突然增加了好几倍。为了解决这个问题，我们可以采取按需引入的方式。")]),t._v(" "),e("p",[t._v("拿antd为例，需要我们在.babelrc文件中这样声明，")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('{\n"presets": [\n   [\n    "@babel/preset-env",\n    {\n      "targets": {\n          "chrome": "67"\n      },\n    "useBuiltIns": "usage",\n     "corejs": 2\n    }\n   ],\n    "@babel/preset-react"\n ],\n  "plugins": [\n  [\n   "@babel/plugin-transform-runtime",\n  ],\n  //重点按需引入antd里面的style\n  [  "import", {\n   "libraryName": "antd",\n   "libraryDirectory": "es",\n   "style": true\n  }]\n ]\n}\n')])])]),e("p",[t._v("经过如上配置之后，我们会发现体积比没有处理的要小很多。")]),t._v(" "),e("h3",{attrs:{id:"问题二-webpack怎么配置多页面应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题二-webpack怎么配置多页面应用"}},[t._v("#")]),t._v(" . 问题二:webpack怎么配置多页面应用？")]),t._v(" "),e("p",[t._v("实际这个问题变相再问webpack，配置多入口和多个html对应")]),t._v(" "),e("p",[e("strong",[t._v("entry")]),t._v(" 应该这么配 ,entry支持 string array object")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{\n  //入口文件配置 string | array | object\n  entry: {\n    index: './src/index.js',\n    list: './src/list.js',\n    detail: './src/detail.js'\n  },\n}\n")])])]),e("p",[e("strong",[t._v("html输出配置")]),t._v(" 输出html需要webpack插件 html-webpack-plugin")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("{\n    plugins: [\n    new htmlWebpackPulgin({\n      title: 'hello 我是首页',\n      template: './index.html',\n      inject: 'head',\n      filename: 'index.html',\n      chunks: ['index'] //对应 index.js\n    }),\n    new htmlWebpackPulgin({\n      title: 'hello 我是列表',\n      template: './index.html',\n      inject: 'body',\n      filename: 'list.html',\n      chunks: ['list'] // 对应 list.js\n    }),\n    new htmlWebpackPulgin({\n      title: 'hello 我是详情',\n      template: './index.html',\n      inject: 'body',\n      filename: 'detail.html',\n      chunks: ['detail']  //对应detail.js\n    })\n  ]\n}\n")])])]),e("h2",{attrs:{id:"http篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http篇"}},[t._v("#")]),t._v(" http篇")]),t._v(" "),e("p",[e("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),e("h3",{attrs:{id:"问题1-url请求页面之后浏览器的解析过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题1-url请求页面之后浏览器的解析过程"}},[t._v("#")]),t._v(" . 问题1:URL请求页面之后浏览器的解析过程")]),t._v(" "),e("p",[t._v("1.用户输入网址，浏览器发起DNS查询请求，域名解析。")]),t._v(" "),e("p",[t._v("2.三次握手")]),t._v(" "),e("p",[t._v("3.建立tcp连接，发送http请求")]),t._v(" "),e("p",[t._v("4.服务器接受到请求,并相应http请求")]),t._v(" "),e("p",[t._v("5.浏览器对返回的html进行解析，在这期间可能继续请求css，js等文件，浏览器渲染、构建网页")]),t._v(" "),e("p",[t._v("6.断开连接，四次挥手")]),t._v(" "),e("p",[t._v("7.浏览器对页面进行渲染呈现给用户")]),t._v(" "),e("h3",{attrs:{id:"问题2-javascript的同源策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题2-javascript的同源策略"}},[t._v("#")]),t._v(" . 问题2:javascript的同源策略")]),t._v(" "),e("p",[t._v("同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。")]),t._v(" "),e("p",[t._v("如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。")]),t._v(" "),e("p",[e("strong",[t._v("源的继承")]),t._v("\n在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。")]),t._v(" "),e("p",[e("strong",[t._v("源的修改")]),t._v("\n满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将 document.domain 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。")]),t._v(" "),e("h3",{attrs:{id:"问题3-怎么解决ie浏览器对get请求的缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题3-怎么解决ie浏览器对get请求的缓存"}},[t._v("#")]),t._v(" . 问题3:怎么解决ie浏览器对get请求的缓存？")]),t._v(" "),e("p",[t._v("不知道大家有没有过一种情况，在低版本ie浏览器下，在短暂的时间内发出相同的get情况（比如相同时间请求一个数据列表多次)，就会发现请求只发送了一次，其他的请求都被浏览器缓存了，对于这种缓存ajax情况，我们可以在url拼上时间戳，这样浏览器就不会认为这是相同的情况，就不会缓存get情况。")]),t._v(" "),e("p",[e("strong",[t._v("以aixos为例，我们可以在每次发起请求的时候对get请求加以拦截")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/* 拦截器 */\naxios.interceptors.request.use(\n    (config) => {\n        const method   = config.method || 'get'\n        if (method.toLowerCase() === 'get') {  /* 防止浏览器缓存 */\n            const url  = config.url || ''\n            const t = new Date().getTime()\n            config.url = `${url}${url.indexOf('?') === -1 ? '?' : '&'}t=${t}`\n        }else if(method.toLowerCase() === 'post'){ /* 设置不同请求头 */\n            //...\n        }\n        return config\n    },\n    (error) => { \n    }\n)\n")])])]),e("p",[t._v("如上，就完美解决了ajax被ie浏览器缓存的问题。")]),t._v(" "),e("h2",{attrs:{id:"参考文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[t._v("#")]),t._v(" 参考文档")]),t._v(" "),e("blockquote",[e("p",[t._v("布局常用解决方案对比(媒体查询、百分比、rem和vw/vh）\ncss中的多种垂直水平居中\nJavaScript内存泄露的4种方式及如何避免\nvue路由守卫哪几种？\nVue组件为什么data必须是一个函数？\n深入 setState 机制")])]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")])])}),[],!1,null,null,null);e.default=s.exports}}]);