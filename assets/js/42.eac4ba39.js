(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{335:function(t,v,_){"use strict";_.r(v);var a=_(4),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("table",[v("thead",[v("tr",[v("th",[t._v("1.0")]),t._v(" "),v("th",[t._v("1.1")]),t._v(" "),v("th",[t._v("2.0")]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("长连接")]),t._v(" "),v("td",[t._v("需要使用"),v("code",[t._v("keep-alive")]),t._v(" 参数来告知服务端建立一个长连接")]),t._v(" "),v("td",[t._v("默认支持")]),t._v(" "),v("td",[t._v("默认支持")])]),t._v(" "),v("tr",[v("td",[t._v("HOST域")]),t._v(" "),v("td",[t._v("✘")]),t._v(" "),v("td",[t._v("✔️")]),t._v(" "),v("td",[t._v("✔️")])]),t._v(" "),v("tr",[v("td",[t._v("多路复用")]),t._v(" "),v("td",[t._v("✘")]),t._v(" "),v("td",[t._v("-")]),t._v(" "),v("td",[t._v("✔️")])]),t._v(" "),v("tr",[v("td",[t._v("数据压缩")]),t._v(" "),v("td",[t._v("✘")]),t._v(" "),v("td",[t._v("✘")]),t._v(" "),v("td",[t._v("使用"),v("code",[t._v("HAPCK")]),t._v("算法对header数据进行压缩，使数据体积变小，传输更快")])]),t._v(" "),v("tr",[v("td",[t._v("服务器推送")]),t._v(" "),v("td",[t._v("✘")]),t._v(" "),v("td",[t._v("✘")]),t._v(" "),v("td",[t._v("✔️")])])])]),t._v(" "),v("h2",{attrs:{id:"http-0-9"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-0-9"}},[t._v("#")]),t._v(" HTTP/0.9")]),t._v(" "),v("p",[t._v("已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。")]),t._v(" "),v("h2",{attrs:{id:"http-1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0"}},[t._v("#")]),t._v(" HTTP/1.0")]),t._v(" "),v("p",[t._v("这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。")]),t._v(" "),v("h2",{attrs:{id:"http-1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP/1.1")]),t._v(" "),v("p",[t._v("持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。")]),t._v(" "),v("blockquote",[v("p",[t._v("HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：\n缓存处理\n带宽优化及网络连接的使用\n错误通知的管理\n消息在网络中的发送\n互联网地址的维护\n安全性及完整性")])]),t._v(" "),v("h2",{attrs:{id:"http-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[t._v("#")]),t._v(" HTTP/2")]),t._v(" "),v("p",[t._v("在 HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括HTTP/1.1中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法(HPACK)[15][16]。此外， HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。[12]")]),t._v(" "),v("h3",{attrs:{id:"帧、消息、流和tcp连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#帧、消息、流和tcp连接"}},[t._v("#")]),t._v(" 帧、消息、流和TCP连接")]),t._v(" "),v("p",[t._v("有别于HTTP/1.1在连接中的明文请求，HTTP/2与SPDY一样，将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。[12]这也是HTTP/1.1与HTTP/2最大的区别所在。 HTTP/2中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个TCP通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。这个举措在SPDY中的实践表明，相比HTTP/1.1，新页面加载可以加快11.81% 到 47.7%[17]")]),t._v(" "),v("h3",{attrs:{id:"hpack-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hpack-算法"}},[t._v("#")]),t._v(" HPACK 算法")]),t._v(" "),v("p",[t._v("HPACK算法是新引入HTTP/2的一个算法，用于对HTTP头部做压缩。其原理在于：")]),t._v(" "),v("p",[t._v("客户端与服务端根据 RFC 7541 的附录A，维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码；\n客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；\n客户端和服务端根据 RFC 7541 的附录B，支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）。")]),t._v(" "),v("h3",{attrs:{id:"服务器推送"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器推送"}},[t._v("#")]),t._v(" 服务器推送")]),t._v(" "),v("p",[t._v("网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多HTTP链接来加载页面和页面资源。")]),t._v(" "),v("p",[t._v("HTTP/2引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。")])])}),[],!1,null,null,null);v.default=r.exports}}]);