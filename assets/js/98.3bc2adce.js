(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{390:function(e,t,v){"use strict";v.r(t);var _=v(4),a=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"react系统复习如何做最高效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react系统复习如何做最高效"}},[e._v("#")]),e._v(" React系统复习如何做最高效")]),e._v(" "),t("h2",{attrs:{id:"一-前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-前言"}},[e._v("#")]),e._v(" 一 前言")]),e._v(" "),t("p",[e._v("哈喽，大家好，我是 alien ，8月24号，我作为分享嘉宾，线上参与了一场 《React 系统复习如何做最高效》 的技术分享，接下来我把直播的内容汇总分享给大家。在分享的过程中，也枚举了一些思考题和一些比较热门的面试题目，一同奉上。")]),e._v(" "),t("p",[e._v("这里非常感谢掘金平台提供一次分享技术的机会，也非常感谢掘友们的热心捧场，整体下来还算是成功的，可能刚开始比较紧张，因为毕竟是第一次直播，人生的第一次直播献给了掘金😂，后来渐渐地找回了状态。这里保存了直播过程中的一些截图，整体下来掘友们还是蛮给力的，也参与互动，提了很多问题。")]),e._v(" "),t("p",[e._v("直播场景：")]),e._v(" "),t("p",[e._v("掘友互动场景")]),e._v(" "),t("p",[e._v("如果想看直播回放的童鞋，请点击这里： "),t("strong",[e._v("https://live.juejin.cn/4354/3168473")])]),e._v(" "),t("p",[e._v("好的，废话不说，进入正题，本次直播分享主要按照以下模块进行的，这些模块是我工作几年来总结的一些经验，同学们可以按照对应的模块进行查缺补漏，")]),e._v(" "),t("ul",[t("li",[e._v("React 基础模块。")]),e._v(" "),t("li",[e._v("React 优化手段。")]),e._v(" "),t("li",[e._v("React 生态掌握。")]),e._v(" "),t("li",[e._v("React 设计模式。")]),e._v(" "),t("li",[e._v("React 核心原理。")]),e._v(" "),t("li",[e._v("React 项目实战。")])]),e._v(" "),t("h2",{attrs:{id:"二-知识点梳理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-知识点梳理"}},[e._v("#")]),e._v(" 二 知识点梳理")]),e._v(" "),t("p",[e._v("上述的模块进行细化，总结的内容如下：")]),e._v(" "),t("p",[t("strong",[e._v("React基础模块：")])]),e._v(" "),t("ul",[t("li",[e._v("操作 "),t("code",[e._v("jsx")]),e._v(" 。")]),e._v(" "),t("li",[e._v("掌握 class 和 function Component。")]),e._v(" "),t("li",[e._v("state 更新机制， "),t("code",[e._v("setState")]),e._v(" 和 "),t("code",[e._v("useState")]),e._v(" 的用法和区别。")]),e._v(" "),t("li",[e._v("理解 "),t("code",[e._v("props")]),e._v(" ，React 中的 props 可以是什么？")]),e._v(" "),t("li",[e._v("类组件生命周期，函数组件生命周期替代方案， "),t("code",[e._v("useEffect")]),e._v(" 和 "),t("code",[e._v("useLayoutEffect")]),e._v("。")]),e._v(" "),t("li",[t("code",[e._v("Ref")]),e._v(" 是什么，能做些什么？")]),e._v(" "),t("li",[t("code",[e._v("css in React")]),e._v("。")])]),e._v(" "),t("p",[t("strong",[e._v("React优化手段")])]),e._v(" "),t("ul",[t("li",[e._v("渲染控制。")]),e._v(" "),t("li",[e._v("渲染调优。")]),e._v(" "),t("li",[e._v("处理海量数据。")]),e._v(" "),t("li",[e._v("细节处理。")])]),e._v(" "),t("p",[t("strong",[e._v("React生态")])]),e._v(" "),t("ul",[t("li",[e._v("React-Router。")]),e._v(" "),t("li",[e._v("React-Redux。")]),e._v(" "),t("li",[e._v("React-Mobx。")]),e._v(" "),t("li",[e._v("项目工程 umi | dva等。")])]),e._v(" "),t("p",[t("strong",[e._v("React设计模式")])]),e._v(" "),t("ul",[t("li",[e._v("组合模式。")]),e._v(" "),t("li",[e._v("render props 模式。")]),e._v(" "),t("li",[e._v("HOC | 装饰器模式。")]),e._v(" "),t("li",[e._v("提供者模式。")]),e._v(" "),t("li",[e._v("自定义 hooks 模式。")])]),e._v(" "),t("p",[t("strong",[e._v("React核心原理")])]),e._v(" "),t("ul",[t("li",[e._v("事件原理。")]),e._v(" "),t("li",[e._v("调和原理。")]),e._v(" "),t("li",[e._v("调度原理。")]),e._v(" "),t("li",[e._v("hooks 原理。")]),e._v(" "),t("li",[e._v("diff 流程等等。")])]),e._v(" "),t("p",[t("strong",[e._v("React实战")])]),e._v(" "),t("ul",[t("li",[e._v("实现表单系统。")]),e._v(" "),t("li",[e._v("实现状态管理工具。")]),e._v(" "),t("li",[e._v("实现路由功能。")]),e._v(" "),t("li",[e._v("自定义 hooks 实践。")])]),e._v(" "),t("p",[e._v("以上就是本次直播的提及的 React 应该学习的知识点。用一幅图来概括。")]),e._v(" "),t("p",[e._v("接下来对每一个功能进行拆解。")]),e._v(" "),t("h2",{attrs:{id:"三-功能拆解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-功能拆解"}},[e._v("#")]),e._v(" 三 功能拆解")]),e._v(" "),t("p",[e._v("分享的内容细化成每一个我们需要掌握的功能点，以问题的形式切入，我们可以尝试一下？")]),e._v(" "),t("h3",{attrs:{id:"_1-react基础模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-react基础模块"}},[e._v("#")]),e._v(" 1 React基础模块")]),e._v(" "),t("h4",{attrs:{id:"基础模块-jsx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础模块-jsx"}},[e._v("#")]),e._v(" 基础模块 jsx")]),e._v(" "),t("p",[e._v("jsx 中总结的知识点：")]),e._v(" "),t("ul",[t("li",[e._v("① 我们写的 jsx 语法最后变成了什么？React JSX -> React element -> React fiber 流程。")]),e._v(" "),t("li",[e._v("② 如何理解 React element?")]),e._v(" "),t("li",[e._v("③ 老版本 React 为什么要引入 React，如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import React from 'react'\nfunction Index(){\n    return <div>let us learn React!</div>\n}\n")])])]),t("ul",[t("li",[e._v("④ 如何操作 React Element ，使其变成可控的？react createElement 和 react cloneElement。")]),e._v(" "),t("li",[e._v("⑤ "),t("code",[e._v("createElement")]),e._v(" 和 "),t("code",[e._v("cloneElement")]),e._v(" 区别。")]),e._v(" "),t("li",[e._v("⑥ React children 操作方法和应用场景？map ，forEach ，count ，toArray ，only。")]),e._v(" "),t("li",[e._v("⑦ jsx 拓展尝鲜例子：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Test(num){\n   console.log(num)\n   useEffect(()=>{\n       console.log('1111')\n   },[])\n   return <div>《React 进阶实践指南》</div>\n}\n\nexport default function Index(){\n    const [ isShow , setIsShow  ]= useState(false)\n    return <div>\n           <button onClick={() => setIsShow(!isShow)} >点击</button>\n           {isShow ? <Test num={1} /> : <Test num={2} />}\n         </div>\n}\n")])])]),t("p",[e._v("如上点击按钮 "),t("code",[e._v("button")]),e._v("，"),t("code",[e._v("useEffect")]),e._v(" 中的 "),t("code",[e._v("console.log('1111')")]),e._v(" 是否打印。")]),e._v(" "),t("p",[t("strong",[e._v("错误分析：")]),e._v(" 点击按钮，切换 "),t("code",[e._v("isShow")]),e._v("，控制两个 Test 组件的挂载 ｜ 卸载，因为组件重复挂载，那么 "),t("code",[e._v("useEffect")]),e._v(" 执行，打印 "),t("code",[e._v("console.log('1111')")]),e._v("，但是实际结果是这样吗？")]),e._v(" "),t("p",[t("strong",[e._v("效果：没有打印")])]),e._v(" "),t("p",[t("strong",[e._v("流程分析：")]),e._v(" 为什么 useEffect 中的 console.log 没有打印呢 ？")]),e._v(" "),t("ul",[t("li",[e._v("首先如果我们明白 jsx -> element -> fiber 流程之后，就不难解释这个现象了，写的两个 Test 组件，本质上被 babel 处理成两个 element 对象，"),t("code",[e._v("element")]),e._v(" 对象中的 type 属性都指向了 Test 组件函数，两个 element 对象唯一区别是 props 不同。")]),e._v(" "),t("li",[e._v("那么在 React 调和阶段 React ，判断 type 指向相同，就会判断它们是一个组件，所以一次更新的只是被判定 props 变化，走的更新逻辑。")]),e._v(" "),t("li",[e._v("然后在 Test 函数中，更新组件不会让依赖项为 "),t("code",[e._v("[]")]),e._v(" 的 "),t("code",[e._v("useEffect")]),e._v("再次执行，所以 "),t("code",[e._v("console.log('1111')")]),e._v(" 不会被打印。")])]),e._v(" "),t("p",[t("strong",[e._v("解决问题：")])]),e._v(" "),t("p",[e._v("如果想要组件挂载 ｜ 卸载效果，那么很简单，给其中的 Test 加入一个 key，就可以解决问题，"),t("code",[e._v("key")]),e._v(" 可以作为组件身份的标示，在下一次更新中，就会根据 key 找到复用的 fiber 节点，如果没有找到，那就会走正常的组件挂载 ｜ 卸载流程了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" {isShow ? <Test num={1} key={1}  /> : <Test num={2} />}\n")])])]),t("h4",{attrs:{id:"基础模块-state"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础模块-state"}},[e._v("#")]),e._v(" 基础模块 state")]),e._v(" "),t("p",[e._v("state 中总结的知识点：")]),e._v(" "),t("ul",[t("li",[e._v("① state 更新机制? state 改变到视图更新的流程。")]),e._v(" "),t("li",[e._v("② state 批量更新的规则，为什么会被打破？")]),e._v(" "),t("li",[e._v("③ setState 是同步还是异步的？")]),e._v(" "),t("li",[e._v("④ 类组件的 "),t("code",[e._v("setState")]),e._v(" 和函数组件的 "),t("code",[e._v("useState")]),e._v(" 有什么共性和区别？")]),e._v(" "),t("li",[e._v("⑤ 函数组件的状态管理方法 useState + useRef ?  useState 负责更新，useRef 负责保存状态。")]),e._v(" "),t("li",[e._v("⑥ state 打印问题：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("handleClick=()=>{\n    setTimeout(()=>{\n        this.setState({ number: 1  })\n    })\n    this.setState({ number: 2  })\n    ReactDOM.flushSync(()=>{\n        this.setState({ number: 3  })\n    })\n    this.setState({ number: 4  })\n}\nrender(){\n   console.log(this.state.number)\n   return <button onClick={ this.handleClick } > 点击 </button>\n}\n")])])]),t("p",[e._v("点击按钮，打印顺序 ？")]),e._v(" "),t("p",[e._v("打印 3 4 1 ，相信不难理解为什么这么打印了。")]),e._v(" "),t("p",[e._v("首先 "),t("code",[e._v("flushSync")]),e._v(" "),t("code",[e._v("this.setState({ number: 3 })")]),e._v(" 设定了一个高优先级的更新，所以 2 和 3 被批量更新到 3 ，所以 3 先被打印。更新为 4。最后更新 setTimeout 中的 number = 1。")]),e._v(" "),t("h4",{attrs:{id:"基础模块-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础模块-component"}},[e._v("#")]),e._v(" 基础模块 component")]),e._v(" "),t("p",[e._v("component 模块包含的知识点：")]),e._v(" "),t("ul",[t("li",[e._v("① 类组件特点，函数组件特点，两者有什么区别？")]),e._v(" "),t("li",[e._v("② 组件的通信方式？")]),e._v(" "),t("li",[e._v("③ 组件的强化方式？")]),e._v(" "),t("li",[e._v("④ React 对组件的处理和处理时机？")]),e._v(" "),t("li",[e._v("⑤ 公共组件的设计规范？")])]),e._v(" "),t("h4",{attrs:{id:"基础模块生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础模块生命周期"}},[e._v("#")]),e._v(" 基础模块生命周期")]),e._v(" "),t("p",[e._v("生命周期知识点：")]),e._v(" "),t("ul",[t("li",[e._v("① 生命周期的介绍，和用法？")]),e._v(" "),t("li",[e._v("② 生命周期的执行时机？父与子生命周期的执行顺序？")]),e._v(" "),t("li",[e._v("③ 函数组件生命周期的代替方案？")]),e._v(" "),t("li",[e._v("④ useEffect 和 useLayoutEffect 有什么区别，应用场景？")]),e._v(" "),t("li",[e._v("⑤ 废弃的生命周期，为什么要废弃？")])]),e._v(" "),t("p",[e._v("一幅图表示 "),t("strong",[e._v("函数组件")]),e._v(" 和 "),t("strong",[e._v("类组件")]),e._v(" 所有生命周期的执行时机（包括已经废弃的生命周期）：")]),e._v(" "),t("h4",{attrs:{id:"基础模块-ref"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础模块-ref"}},[e._v("#")]),e._v(" 基础模块 Ref")]),e._v(" "),t("p",[e._v("ref 知识点总结：")]),e._v(" "),t("ul",[t("li",[e._v("① Ref 对象，以及两种 ref 对象创建方法。useRef 和 createRef")]),e._v(" "),t("li",[e._v("② Ref 有什么作用？1 获取组件实例，DOM元素 ；2 组件通信 ；3 保存状态；")]),e._v(" "),t("li",[e._v("③ Ref 原理 ？"),t("code",[e._v("commitAttachRef")]),e._v(" 和 "),t("code",[e._v("commitDetachRef")]),e._v("。")]),e._v(" "),t("li",[e._v("④ Ref 获取的三种方式？function ；Ref 对象 ；String ；")]),e._v(" "),t("li",[e._v("⑤ 如何跨层级传递 ref ?")]),e._v(" "),t("li",[e._v("⑥ 父组件如何获取函数子组件内部状态？")])]),e._v(" "),t("h4",{attrs:{id:"基础模块-css-in-react"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础模块-css-in-react"}},[e._v("#")]),e._v(" 基础模块 Css in React")]),e._v(" "),t("p",[e._v("css 模块总结：")]),e._v(" "),t("ul",[t("li",[e._v("① React css 模块化方案。")]),e._v(" "),t("li",[e._v("② css module 掌握。")]),e._v(" "),t("li",[e._v("③ css in js 掌握。")])]),e._v(" "),t("h3",{attrs:{id:"_2-react-优化手段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-react-优化手段"}},[e._v("#")]),e._v(" 2 React 优化手段")]),e._v(" "),t("p",[e._v("React 优化手段总结：")]),e._v(" "),t("ul",[t("li",[e._v("① React 渲染控制的方法？。缓存 react element ，pureComponent ，Memo ，shouldComponentUpdate")]),e._v(" "),t("li",[e._v("② shallowEqual 浅比较原理。")]),e._v(" "),t("li",[e._v("③ React 中节流防抖运用。")]),e._v(" "),t("li",[e._v("④ 合理运用状态管理。")]),e._v(" "),t("li",[e._v("⑤ 按需引入。减少项目体积。")]),e._v(" "),t("li",[e._v("⑥ 代码分割 lazy ，异步组件 Suspense 及其原理。")]),e._v(" "),t("li",[e._v("⑦ diff 算法，合理应用 key 。")]),e._v(" "),t("li",[e._v("⑧ 渲染错误边界，"),t("code",[e._v("componentDidCatch")]),e._v("。")]),e._v(" "),t("li",[e._v("⑨ 状态管理工具和 immutable.js 使用。")]),e._v(" "),t("li",[e._v("⑩ useMemo 缓存逻辑。")]),e._v(" "),t("li",[e._v("⑪ memo 的缓存策略。")])]),e._v(" "),t("h3",{attrs:{id:"_3-react-生态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-react-生态"}},[e._v("#")]),e._v(" 3 React 生态")]),e._v(" "),t("p",[e._v("React 生态总结：react-router，react-redux ，react-mobx umi dva 等。")]),e._v(" "),t("ul",[t("li",[e._v("① 两种路由模式 ｜ spa 单页面路由原理。")]),e._v(" "),t("li",[e._v("② React router 使用，实现动态路由，自定义路由。")]),e._v(" "),t("li",[e._v("③ Route. Router Switch 分工。")]),e._v(" "),t("li",[e._v("④ 权限路由封装。")]),e._v(" "),t("li",[e._v("⑤ Mobx-react 使用。")]),e._v(" "),t("li",[e._v("⑥ Mobx 和 React Redux 区别？")]),e._v(" "),t("li",[e._v("⑦ Mobx 原理，收集依赖，触发更新。")]),e._v(" "),t("li",[e._v("⑧ React Redux 和 Redux 使用。")]),e._v(" "),t("li",[e._v("⑨ Redux 设计模式 ｜ 中间件原理。")]),e._v(" "),t("li",[e._v("⑩ React Redux  原理？")]),e._v(" "),t("li",[e._v("⑪ react redux 衍生：dva React-saga 等")]),e._v(" "),t("li",[e._v("⑫ React Redux 中 connect 原理 （这里推荐大家看一下源码，学习一下 hooks使用）。")])]),e._v(" "),t("h3",{attrs:{id:"_4-react-设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-react-设计模式"}},[e._v("#")]),e._v(" 4 React 设计模式")]),e._v(" "),t("p",[e._v("React 设计模式总结：")]),e._v(" "),t("ul",[t("li",[e._v("① React 几种设计模式总结。组合模式，render props模式，提供者模式， hoc 模式，自定义hooks 模式。")]),e._v(" "),t("li",[e._v("② 新老版本 context 用法特点。")]),e._v(" "),t("li",[e._v("③ React context 特点。逐层传递，发布订阅。")]),e._v(" "),t("li",[e._v("④ 新版本 context 消费者几种方式。contextType ，useContext ，consumer")]),e._v(" "),t("li",[e._v("⑤ hoc 两种方式，优缺点？属性代理，反向继承。")]),e._v(" "),t("li",[e._v("⑥ hoc 如何解决静态属性继承问题。")]),e._v(" "),t("li",[e._v("⑦ hoc 如何解决 ref 获取问题。")]),e._v(" "),t("li",[e._v("⑧ hoc 注意事项。")]),e._v(" "),t("li",[e._v("⑨ 自定义 hooks 设计。")]),e._v(" "),t("li",[e._v("⑩ 自定义 hooks 实践。")])]),e._v(" "),t("p",[e._v("以下是一些经典设计模式的代码片段（供大家参考）：")]),e._v(" "),t("p",[t("strong",[e._v("组合模式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<Form ref={ form } >\n    <FormItem name="name" label="我是"  >\n        <Input   />\n    </FormItem>\n    <FormItem name="mes" label="我想对大家说"  >\n        <Input   />\n    </FormItem>\n    <input  placeholder="不需要的input" />\n    <Input/>\n</Form>\n')])])]),t("p",[t("strong",[e._v("提供者模式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function ConsumerDemo(){\n     const { color,background } = React.useContext(ThemeContext)\n    return <div style={{ color,background } } >消费者</div> \n}\nconst Son = React.memo(()=> <ConsumerDemo />) // 子组件\n\nconst ThemeProvider = ThemeContext.Provider //提供者\nexport default function ProviderDemo(){\n    const [ contextValue , setContextValue ] = React.useState({  color:'#ccc', background:'pink' })\n    return <div>\n        <ThemeProvider value={ contextValue } >\n            <Son />\n        </ThemeProvider>\n        <button onClick={ ()=> setContextValue({ color:'#fff' , background:'blue' })  } >切换主题</button>\n    </div>\n}\n")])])]),t("p",[t("strong",[e._v("render props模式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const Index = ()=>{\n    return <Container>\n        <Children />\n        { (ContainerProps)=> <Children {...ContainerProps} name={'haha'}  />  }\n    </Container>\n}\n")])])]),t("p",[t("strong",[e._v("hoc模式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@HOC1(styles)\n@HOC2\n@HOC3\nclass Index extends React.Componen{\n    /* ... */\n}\n")])])]),t("p",[t("strong",[e._v("自定义hooks模式")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function useXXX(){\n    const value = React.useContext(defaultContext)\n    /* .....用上下文中 value 一段初始化逻辑  */\n    const newValue = initValueFunction(value) /* 初始化 value 得到新的 newValue  */\n    /* ...... */\n    return newValue\n}\n")])])]),t("h3",{attrs:{id:"_5-react-核心原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-react-核心原理"}},[e._v("#")]),e._v(" 5 React 核心原理")]),e._v(" "),t("p",[e._v("React 核心原理总结：")]),e._v(" "),t("p",[t("strong",[e._v("fiber原理")])]),e._v(" "),t("ul",[t("li",[e._v("① 什么是fiber ? Fiber 架构解决了什么问题？")]),e._v(" "),t("li",[e._v("② Fiber root 和 root fiber 有什么区别？")]),e._v(" "),t("li",[e._v("③ 不同fiber 之间如何建立起关联的？")]),e._v(" "),t("li",[e._v("④ React 调和流程？")]),e._v(" "),t("li",[e._v("⑤ 两大阶段 commit 和 render 都做了哪些事情？")]),e._v(" "),t("li",[e._v("⑥ 什么是双缓冲树？有什么作用？")]),e._v(" "),t("li",[e._v("⑦ Fiber 深度遍历流程？")]),e._v(" "),t("li",[e._v("⑧ Fiber的调和能中断吗？如何中断？")])]),e._v(" "),t("p",[t("strong",[e._v("调度原理")])]),e._v(" "),t("ul",[t("li",[e._v("① 异步调度原理？")]),e._v(" "),t("li",[e._v("② React 为什么不用 settimeout ？")]),e._v(" "),t("li",[e._v("③ 说一说React 的时间分片？")]),e._v(" "),t("li",[e._v("④ React 如何模拟 requestIdleCallback？")]),e._v(" "),t("li",[e._v("⑤ 简述一下调度流程？")])]),e._v(" "),t("p",[t("strong",[e._v("hooks原理")])]),e._v(" "),t("ul",[t("li",[e._v("① React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。")]),e._v(" "),t("li",[e._v("② React Hooks 如何把状态保存起来？保存的信息存在了哪里？")]),e._v(" "),t("li",[e._v("③ React Hooks 为什么不能写在条件语句中？")]),e._v(" "),t("li",[e._v("④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。")]),e._v(" "),t("li",[e._v("⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调函数 create 重新执行。")]),e._v(" "),t("li",[e._v("⑥ React 内部如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？")])]),e._v(" "),t("p",[t("strong",[e._v("事件原理")])]),e._v(" "),t("ul",[t("li",[e._v("① React 为什么有自己的事件系统？")]),e._v(" "),t("li",[e._v("② 什么是事件合成 ？")]),e._v(" "),t("li",[e._v("③ 如何实现的批量更新？")]),e._v(" "),t("li",[e._v("④ 事件系统如何模拟冒泡和捕获阶段？")]),e._v(" "),t("li",[e._v("⑤ 如何通过 dom 元素找到与之匹配的fiber？")]),e._v(" "),t("li",[e._v("⑥ 为什么不能用 return false 来阻止事件的默认行为？")]),e._v(" "),t("li",[e._v("⑦ 事件是绑定在真实的dom上吗？如何不是绑定在哪里？")]),e._v(" "),t("li",[e._v("⑧ V17 对事件系统有哪些改变")])]),e._v(" "),t("h3",{attrs:{id:"_6-react-实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-react-实践"}},[e._v("#")]),e._v(" 6 React 实践")]),e._v(" "),t("p",[e._v("实践是检验真理的唯一标准，如果想要进阶 React ，在理论知识基础上，也需要去尝试敲代码。")]),e._v(" "),t("ul",[t("li",[e._v("如过没有做过React 项目，尝试写一个 demo 。")]),e._v(" "),t("li",[e._v("尝试写一个公共组件。")]),e._v(" "),t("li",[e._v("尝试写一个高阶组件。")]),e._v(" "),t("li",[e._v("尝试写一个自定义 hooks。")]),e._v(" "),t("li",[e._v("尝试在项目中使用多种设计模式。")])]),e._v(" "),t("h3",{attrs:{id:"_7-react-学习的几个重要阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-react-学习的几个重要阶段"}},[e._v("#")]),e._v(" 7 React 学习的几个重要阶段")]),e._v(" "),t("p",[e._v("进阶 React 可以按照以下阶段去进阶。")]),e._v(" "),t("ul",[t("li",[e._v("第一阶段：明白基础 api ,尝试写项目，多尝试一些复杂的逻辑场景。会用一些React生态。")]),e._v(" "),t("li",[e._v("第二阶段：尝试封装一些基础组件，hoc，尝试使用一些设计模式。")]),e._v(" "),t("li",[e._v("第三阶段：学习一些原理，可以尝试看一下核心源码。")]),e._v(" "),t("li",[e._v("第四阶段：可以自己根据业务需求写一些库，考虑开源。")])]),e._v(" "),t("h2",{attrs:{id:"四-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-总结"}},[e._v("#")]),e._v(" 四 总结")]),e._v(" "),t("p",[e._v("以上就是本次直播分享 React 系统学习部分的内容，大家可以根据自己对 React 的掌握程度，进行查缺补漏，最后祝愿大家早日进阶 React 技术栈。")]),e._v(" "),t("h2",{attrs:{id:"《react进阶实践指南小册》"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#《react进阶实践指南小册》"}},[e._v("#")]),e._v(" 《React进阶实践指南小册》")]),e._v(" "),t("p",[e._v("本次分享的知识点，在这本小册中都能找到答案。目前小册已经完结，是终点亦是起点,  小册内容将持续更新，随着 React 版本升级持续维护，并有持续更新章节～ 提前透露，小册接下来会补充："),t("code",[e._v("React context")]),e._v(" 原理部分，内容补充到第八章。奉上几个小册 7 折 优惠码")])])}),[],!1,null,null,null);t.default=a.exports}}]);