(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{364:function(a,t,e){"use strict";e.r(t);var s=e(4),n=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"javascript运算符使用技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript运算符使用技巧"}},[a._v("#")]),a._v(" JavaScript运算符使用技巧")]),a._v(" "),t("h4",{attrs:{id:"一、可选链接运算符【-】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、可选链接运算符【-】"}},[a._v("#")]),a._v(" 一、可选链接运算符【？.】")]),a._v(" "),t("p",[t("strong",[a._v("可选链接运算符（Optional Chaining Operator）")]),a._v(" 处于ES2020提案的第4阶段，因此应将其添加到规范中。它改变了访问对象内部属性的方式，尤其是深层嵌套的属性。它也可以作为TypeScript 3.7+中的功能使用。")]),a._v(" "),t("p",[a._v("相信大部分开发前端的的小伙伴们都会遇到null和未定义的属性。JS语言的动态特性使其无法不碰到它们。特别是在处理嵌套对象时，以下代码很常见：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("if (data && data.children && data.children[0] && data.children[0].title) {\n    // I have a title!\n} \n")])])]),t("p",[a._v("上面的代码用于API响应，我必须解析JSON以确保名称存在。但是，当对象具有可选属性或某些配置对象具有某些值的动态映射时，可能会遇到类似情况，需要检查很多边界条件。")]),a._v(" "),t("p",[a._v("这时候，如果我们使用可选链接运算符，一切就变得更加轻松了。它为我们检查嵌套属性，而不必显式搜索梯形图。我们所要做的就是使用“？” 要检查空值的属性之后的运算符。我们可以随意在表达式中多次使用该运算符，并且如果未定义任何项，它将尽早返回。")]),a._v(" "),t("p",[t("strong",[a._v("对于静态属性")]),a._v("用法是：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("object?.property\n")])])]),t("p",[t("strong",[a._v("对于动态属性")]),a._v("将其更改为：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("object?.[expression] \n")])])]),t("p",[a._v("上面的代码可以简化为：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let title = data?.children?.[0]?.title;\n")])])]),t("p",[a._v("然后，如果我们有:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v(" let data;\nconsole.log(data?.children?.[0]?.title) // undefined\n\ndata  = {children: [{title:'codercao'}]}\nconsole.log(data?.children?.[0]?.title) // codercao\n")])])]),t("p",[a._v("这样写是不是更加简单了呢？由于操作符一旦为空值就会终止，因此也可以使用它来有条件地调用方法或应用条件逻辑")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v(" const conditionalProperty = null;\nlet index = 0;\n\nconsole.log(conditionalProperty?.[index++]); // undefined\nconsole.log(index);  // 0\n")])])]),t("p",[t("strong",[a._v("对于方法")]),a._v("的调用你可以这样写")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("object.runsOnlyIfMethodExists?.()\n")])])]),t("p",[a._v("例如下面的"),t("code",[a._v("parent")]),a._v("对象，如果我们直接调用"),t("code",[a._v("parent.getTitle()")]),a._v(",则会报"),t("code",[a._v("Uncaught TypeError: parent.getTitle is not a function")]),a._v("错误，"),t("code",[a._v("parent.getTitle?.()")]),a._v("则会终止不会执行")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('let parent = {\n    name: "parent",\n    friends: ["p1", "p2", "p3"],\n    getName: function() {\n      console.log(this.name)\n    }\n  };\n  \n  parent.getName?.()   // parent\n  parent.getTitle?.()  //不会执行 \n')])])]),t("p",[t("strong",[a._v("与无效合并一起使用")])]),a._v(" "),t("p",[a._v("提供了一种方法来处理未定义或为空值和表达提供默认值。我们可以使用"),t("code",[a._v("??")]),a._v("运算符，为表达式提供默认值")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("console.log(undefined ?? 'codercao'); // codercao\n")])])]),t("p",[a._v("因此，如果属性不存在，则可以将无效的合并运算符与可选链接运算符结合使用以提供默认值。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let title = data?.children?.[0]?.title ?? 'codercao';\nconsole.log(title); // codercao\n")])])]),t("h4",{attrs:{id:"二、逻辑空分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、逻辑空分配"}},[a._v("#")]),a._v(" 二、逻辑空分配（?? =）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("expr1 ??= expr2\n")])])]),t("p",[a._v("逻辑空值运算符仅在空值（ "),t("code",[a._v("null")]),a._v(" 或者 "),t("code",[a._v("undefined")]),a._v("）时才将值分配给expr1，表达方式：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x ??= y\n")])])]),t("p",[a._v("可能看起来等效于：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x = x ?? y;\n")])])]),t("p",[a._v("但事实并非如此！有细微的差别。")]),a._v(" "),t("p",[a._v("空的合并运算符（??）从左到右操作，如果x不为空，则短路。因此，如果x不为 "),t("code",[a._v("null")]),a._v(" 或者 "),t("code",[a._v("undefined")]),a._v("，则永远不会对表达式"),t("code",[a._v("y")]),a._v("进行求值。因此，如果"),t("code",[a._v("y")]),a._v("是一个函数，它将根本不会被调用。因此，此逻辑赋值运算符等效于")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x ?? (x = y);\n")])])]),t("h4",{attrs:{id:"三、逻辑或分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、逻辑或分配"}},[a._v("#")]),a._v(" 三、逻辑或分配（|| =）")]),a._v(" "),t("p",[a._v("此逻辑赋值运算符仅在左侧表达式为 "),t("strong",[a._v("falsy值")]),a._v('时才赋值。Falsy值与null有所不同，因为falsy值可以是任何一种值：undefined，null，空字符串(双引号""、单引号’’、反引号``)，NaN，0。IE浏览器中的 document.all，也算是一个。')]),a._v(" "),t("p",[a._v("语法")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x ||= y\n")])])]),t("p",[a._v("等同于")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x || (x = y)\n")])])]),t("p",[a._v("在我们想要保留现有值（如果不存在）的情况下，这很有用，否则我们想为其分配默认值。例如，如果搜索请求中没有数据，我们希望将元素的内部HTML设置为默认值。否则，我们要显示现有列表。这样，我们避免了不必要的更新和任何副作用，例如解析，重新渲染，失去焦点等。我们可以简单地使用此运算符来使用JavaScript更新HTML：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("document.getElementById('search').innerHTML ||= '<i>No posts found matching this search.</i>'\n")])])]),t("h4",{attrs:{id:"四、逻辑与分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、逻辑与分配"}},[a._v("#")]),a._v(" 四、逻辑与分配（&& =）")]),a._v(" "),t("p",[a._v("可能你已经猜到了，此逻辑赋值运算符仅在左侧为真时才赋值。因此：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x &&= y\n")])])]),t("p",[a._v("等同于")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("x && (x = y)\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);