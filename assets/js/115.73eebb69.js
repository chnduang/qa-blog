(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{406:function(t,_,v){"use strict";v.r(_);var e=v(4),a=Object(e.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"说说你在使用react-过程中遇到的常见问题-解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说你在使用react-过程中遇到的常见问题-解决方案"}},[t._v("#")]),t._v(" 说说你在使用React 过程中遇到的常见问题？解决方案?")]),t._v(" "),_("blockquote",[_("p",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/UXrmh_nAbruE-7zrieK1OQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/UXrmh_nAbruE-7zrieK1OQ"),_("OutboundLink")],1)]),t._v(" "),_("p",[_("a",{attrs:{href:"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU1OTgxNDQ1Nw==&action=getalbum&album_id=1923987669068349443&scene=173&from_msgid=2247488842&from_itemidx=1&count=3&nolastread=1#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU1OTgxNDQ1Nw==&action=getalbum&album_id=1923987669068349443&scene=173&from_msgid=2247488842&from_itemidx=1&count=3&nolastread=1#wechat_redirect"),_("OutboundLink")],1)])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibRcPbkB28WIQJCdGwlM7uexMhRG6nTOria240c2zWkVslfzNhapPibZK60iaKJmmvAFhh6lCFibG7SCmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),_("h2",{attrs:{id:"一、前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、前言"}},[t._v("#")]),t._v(" 一、前言")]),t._v(" "),_("p",[t._v("在使用"),_("code",[t._v("react")]),t._v('开发项目过程中，每个人或多或少都会遇到一些"奇怪"的问题，本质上都是我们对其理解的不够透彻')]),t._v(" "),_("p",[_("code",[t._v("react")]),t._v(" 系列，33个工作日，33次凌晨还在亮起的台灯，到今天就圆满画上句号了，比心")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/gH31uF9VIibRcPbkB28WIQJCdGwlM7uexDuc38GUFVv9gqUGfu5wVXKU8Cexny0sHEiar6ysZCRG6C0Hb6YQw3Vw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),t._v(" "),_("p",[t._v("在系列中我们列出了很多比较经典的考题，工作中遇到的问题也往往就藏中其中，只是以不同的表现形式存在罢了")]),t._v(" "),_("p",[t._v("今天的题解不算题解，准确来说是对整个系列的一次贯穿，总结")]),t._v(" "),_("p",[t._v("目录:")]),t._v(" "),_("ul",[_("li",[t._v("react 有什么特性")]),t._v(" "),_("li",[t._v("生命周期有哪些不同阶段？每个阶段对应的方法是？")]),t._v(" "),_("li",[t._v("state 和 props有什么区别？")]),t._v(" "),_("li",[t._v("super()和super(props)有什么区别？")]),t._v(" "),_("li",[t._v("setState执行机制？")]),t._v(" "),_("li",[t._v("React的事件机制？")]),t._v(" "),_("li",[t._v("事件绑定的方式有哪些？")]),t._v(" "),_("li",[t._v("构建组件的方式有哪些？区别？")]),t._v(" "),_("li",[t._v("组件之间如何通信？")]),t._v(" "),_("li",[t._v("key有什么作用？")]),t._v(" "),_("li",[t._v("refs 的理解？应用场景？")]),t._v(" "),_("li",[t._v("Hooks的理解？解决了什么问题？")]),t._v(" "),_("li",[t._v("如何引入css？")]),t._v(" "),_("li",[t._v("redux工作原理？")]),t._v(" "),_("li",[t._v("redux中间件有哪些？")]),t._v(" "),_("li",[t._v("react-router组件有哪些？")]),t._v(" "),_("li",[t._v("render触发时机？")]),t._v(" "),_("li",[t._v("如何减少render？")]),t._v(" "),_("li",[t._v("JSX转化DOM过程？")]),t._v(" "),_("li",[t._v("性能优化手段有哪些")]),t._v(" "),_("li",[t._v("如何做服务端渲染？")])]),t._v(" "),_("h3",{attrs:{id:"react-有什么特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-有什么特性"}},[t._v("#")]),t._v(" react 有什么特性")]),t._v(" "),_("p",[t._v("主要的特性分为：")]),t._v(" "),_("ul",[_("li",[t._v("JSX语法")]),t._v(" "),_("li",[t._v("单向数据绑定")]),t._v(" "),_("li",[t._v("虚拟DOM")]),t._v(" "),_("li",[t._v("声明式编程")]),t._v(" "),_("li",[t._v("Component")])]),t._v(" "),_("p",[t._v("借助这些特性，"),_("code",[t._v("react")]),t._v("整体使用起来更加简单高效，组件式开发提高了代码的复用率")]),t._v(" "),_("h3",{attrs:{id:"生命周期有哪些不同阶段-每个阶段对应的方法是"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生命周期有哪些不同阶段-每个阶段对应的方法是"}},[t._v("#")]),t._v(" 生命周期有哪些不同阶段？每个阶段对应的方法是？")]),t._v(" "),_("p",[t._v("主要分成了新的生命周期和旧的生命周期：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("新版生命周期整体流程如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/qdzhou/img-upload/raw/master/images/202112281554925.png",alt:"图片"}})]),t._v(" "),_("p",[t._v("旧的生命周期流程图如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/qdzhou/img-upload/raw/master/images/202112281554964.png",alt:"图片"}})])])]),t._v(" "),_("h3",{attrs:{id:"state-和-props有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#state-和-props有什么区别"}},[t._v("#")]),t._v(" state 和 props有什么区别？")]),t._v(" "),_("p",[t._v("两者相同点：")]),t._v(" "),_("ul",[_("li",[t._v("两者都是 JavaScript 对象")]),t._v(" "),_("li",[t._v("两者都是用于保存信息")]),t._v(" "),_("li",[t._v("props 和 state 都能触发渲染更新")])]),t._v(" "),_("p",[t._v("区别：")]),t._v(" "),_("ul",[_("li",[t._v("props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化")]),t._v(" "),_("li",[t._v("props 在组件内部是不可修改的，但 state 在组件内部可以进行修改")]),t._v(" "),_("li",[t._v("state 是多变的、可以修改")])]),t._v(" "),_("h3",{attrs:{id:"super-和super-props-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#super-和super-props-有什么区别"}},[t._v("#")]),t._v(" super()和super(props)有什么区别？")]),t._v(" "),_("p",[t._v("在"),_("code",[t._v("React")]),t._v("中，类组件基于"),_("code",[t._v("ES6")]),t._v("，所以在"),_("code",[t._v("constructor")]),t._v("中必须使用"),_("code",[t._v("super")])]),t._v(" "),_("p",[t._v("在调用"),_("code",[t._v("super")]),t._v("过程，无论是否传入"),_("code",[t._v("props")]),t._v("，"),_("code",[t._v("React")]),t._v("内部都会将"),_("code",[t._v("porps")]),t._v("赋值给组件实例"),_("code",[t._v("porps")]),t._v("属性中")]),t._v(" "),_("p",[t._v("如果只调用了"),_("code",[t._v("super()")]),t._v("，那么"),_("code",[t._v("this.props")]),t._v("在"),_("code",[t._v("super()")]),t._v("和构造函数结束之间仍是"),_("code",[t._v("undefined")])]),t._v(" "),_("h3",{attrs:{id:"setstate执行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#setstate执行机制"}},[t._v("#")]),t._v(" setState执行机制？")]),t._v(" "),_("p",[t._v("在"),_("code",[t._v("react")]),t._v("类组件的状态需要通过"),_("code",[t._v("setState")]),t._v("进行更改，在不同场景下对应不同的执行顺序：")]),t._v(" "),_("ul",[_("li",[t._v("在组件生命周期或React合成事件中，setState是异步")]),t._v(" "),_("li",[t._v("在setTimeout或者原生dom事件中，setState是同步")])]),t._v(" "),_("p",[t._v("当我们批量更改"),_("code",[t._v("state")]),t._v("的值的时候，"),_("code",[t._v("react")]),t._v("内部会将其进行覆盖，只取最后一次的执行结果")]),t._v(" "),_("p",[t._v("当需要下一个"),_("code",[t._v("state")]),t._v("依赖当前"),_("code",[t._v("state")]),t._v("的时候，则可以在"),_("code",[t._v("setState")]),t._v("中传递一个回调函数进行下次更新")]),t._v(" "),_("h3",{attrs:{id:"react的事件机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react的事件机制"}},[t._v("#")]),t._v(" React的事件机制？")]),t._v(" "),_("p",[_("code",[t._v("React")]),t._v("基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等")]),t._v(" "),_("p",[t._v("组件注册的事件最终会绑定在"),_("code",[t._v("document")]),t._v("这个 "),_("code",[t._v("DOM")]),t._v("上，而不是 "),_("code",[t._v("React")]),t._v("组件对应的 "),_("code",[t._v("DOM")]),t._v("，从而节省内存开销")]),t._v(" "),_("p",[t._v("自身实现了一套事件冒泡机制，阻止不同时间段的冒泡行为，需要对应使用不同的方法")]),t._v(" "),_("h3",{attrs:{id:"事件绑定的方式有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件绑定的方式有哪些"}},[t._v("#")]),t._v(" 事件绑定的方式有哪些？")]),t._v(" "),_("p",[_("code",[t._v("react")]),t._v("常见的绑定方式有如下：")]),t._v(" "),_("ul",[_("li",[t._v("render方法中使用bind")]),t._v(" "),_("li",[t._v("render方法中使用箭头函数")]),t._v(" "),_("li",[t._v("constructor中bind")]),t._v(" "),_("li",[t._v("定义阶段使用箭头函数绑定")])]),t._v(" "),_("p",[t._v("前两种方式在每次组件"),_("code",[t._v("render")]),t._v("的时候都会生成新的方法实例，性能问题欠缺")]),t._v(" "),_("h3",{attrs:{id:"构建组件的方式有哪些-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构建组件的方式有哪些-区别"}},[t._v("#")]),t._v(" 构建组件的方式有哪些？区别？")]),t._v(" "),_("p",[t._v("组件的创建主要分成了三种方式：")]),t._v(" "),_("ul",[_("li",[t._v("函数式创建")]),t._v(" "),_("li",[t._v("继承 React.Component 创建")]),t._v(" "),_("li",[t._v("通过 React.createClass 方法创建")])]),t._v(" "),_("p",[t._v("如今一般都是前两种方式，对于一些无状态的组件创建，建议使用函数式创建的方式，再比如"),_("code",[t._v("hooks")]),t._v("的机制下，函数式组件能做类组件对应的事情，所以建议都使用函数式的方式来创建组件")]),t._v(" "),_("h3",{attrs:{id:"组件之间如何通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件之间如何通信"}},[t._v("#")]),t._v(" 组件之间如何通信？")]),t._v(" "),_("p",[t._v("组件间通信可以通过"),_("code",[t._v("props")]),t._v("、传递回调函数、"),_("code",[t._v("context")]),t._v("、"),_("code",[t._v("redux")]),t._v("等形式进行组件之间通讯")]),t._v(" "),_("h3",{attrs:{id:"key有什么作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#key有什么作用"}},[t._v("#")]),t._v(" key有什么作用？")]),t._v(" "),_("p",[t._v("使用"),_("code",[t._v("key")]),t._v("是"),_("code",[t._v("react")]),t._v("性能优化的手段，在一系列数据最前面插入元素，如果没有"),_("code",[t._v("key")]),t._v("的值，则所有的元素都需要进行更换，而有"),_("code",[t._v("key")]),t._v("的情况只需要将最新元素插入到前面，不涉及删除操作")]),t._v(" "),_("p",[t._v("在使用"),_("code",[t._v("key")]),t._v("的时候应保证：")]),t._v(" "),_("ul",[_("li",[t._v("key 应该是唯一的")]),t._v(" "),_("li",[t._v("key不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）")]),t._v(" "),_("li",[t._v("避免使用 index 作为 key")])]),t._v(" "),_("h3",{attrs:{id:"refs-的理解-应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#refs-的理解-应用场景"}},[t._v("#")]),t._v(" refs 的理解？应用场景？")]),t._v(" "),_("p",[_("code",[t._v("Refs")]),t._v("允许我们访问 "),_("code",[t._v("DOM")]),t._v("节点或在 "),_("code",[t._v("render")]),t._v("方法中创建的 "),_("code",[t._v("React")]),t._v("元素")]),t._v(" "),_("p",[t._v("下面的场景使用"),_("code",[t._v("refs")]),t._v("非常有用：")]),t._v(" "),_("ul",[_("li",[t._v("对Dom元素的焦点控制、内容选择、控制")]),t._v(" "),_("li",[t._v("对Dom元素的内容设置及媒体播放")]),t._v(" "),_("li",[t._v("对Dom元素的操作和对组件实例的操作")]),t._v(" "),_("li",[t._v("集成第三方 DOM 库")])]),t._v(" "),_("h3",{attrs:{id:"hooks的理解-解决了什么问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hooks的理解-解决了什么问题"}},[t._v("#")]),t._v(" Hooks的理解？解决了什么问题？")]),t._v(" "),_("p",[_("code",[t._v("Hook")]),t._v(" 是 React 16.8 的新增特性。它可以让你在不编写 "),_("code",[t._v("class")]),t._v(" 的情况下使用 "),_("code",[t._v("state")]),t._v(" 以及其他的 "),_("code",[t._v("React")]),t._v(" 特性")]),t._v(" "),_("p",[t._v("解决问题如下：")]),t._v(" "),_("ul",[_("li",[t._v("难以重用和共享组件中的与状态相关的逻辑")]),t._v(" "),_("li",[t._v("逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面")]),t._v(" "),_("li",[t._v("类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题")]),t._v(" "),_("li",[t._v("由于业务变动，函数组件不得不改为类组件等等")])]),t._v(" "),_("h3",{attrs:{id:"如何引入css"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何引入css"}},[t._v("#")]),t._v(" 如何引入css？")]),t._v(" "),_("p",[t._v("常见的"),_("code",[t._v("CSS")]),t._v("引入方式有以下：")]),t._v(" "),_("ul",[_("li",[t._v("在组件内直接使用")]),t._v(" "),_("li",[t._v("组件中引入 .css 文件")]),t._v(" "),_("li",[t._v("组件中引入 .module.css 文件")]),t._v(" "),_("li",[t._v("CSS in JS")])]),t._v(" "),_("p",[t._v("组件内直接使用"),_("code",[t._v("css")]),t._v("会导致大量的代码，而文件中直接引入"),_("code",[t._v("css")]),t._v("文件是全局作用域，发生层叠")]),t._v(" "),_("p",[t._v("引入"),_("code",[t._v(".module.css")]),t._v("文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写")]),t._v(" "),_("p",[_("code",[t._v("css in js")]),t._v("这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等")]),t._v(" "),_("h3",{attrs:{id:"redux工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redux工作原理"}},[t._v("#")]),t._v(" redux工作原理？")]),t._v(" "),_("p",[_("code",[t._v("redux")]),t._v("要求我们把数据都放在 "),_("code",[t._v("store")]),t._v("公共存储空间")]),t._v(" "),_("p",[t._v("一个组件改变了 "),_("code",[t._v("store")]),t._v(" 里的数据内容，其他组件就能感知到 "),_("code",[t._v("store")]),t._v("的变化，再来取数据，从而间接的实现了这些数据传递的功能")]),t._v(" "),_("p",[t._v("工作流程图如下所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://gitee.com/qdzhou/img-upload/raw/master/images/202112281555712.png",alt:"图片"}})]),t._v(" "),_("h3",{attrs:{id:"redux中间件有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redux中间件有哪些"}},[t._v("#")]),t._v(" redux中间件有哪些？")]),t._v(" "),_("p",[t._v("市面上有很多优秀的"),_("code",[t._v("redux")]),t._v("中间件，如：")]),t._v(" "),_("ul",[_("li",[t._v("redux-thunk：用于异步操作")]),t._v(" "),_("li",[t._v("redux-logger：用于日志记录")])]),t._v(" "),_("h3",{attrs:{id:"react-router组件有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-router组件有哪些"}},[t._v("#")]),t._v(" react-router组件有哪些？")]),t._v(" "),_("p",[t._v("常见的组件有：")]),t._v(" "),_("ul",[_("li",[t._v("BrowserRouter、HashRouter")]),t._v(" "),_("li",[t._v("Route")]),t._v(" "),_("li",[t._v("Link、NavLink")]),t._v(" "),_("li",[t._v("switch")]),t._v(" "),_("li",[t._v("redirect")])]),t._v(" "),_("h3",{attrs:{id:"render触发时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#render触发时机"}},[t._v("#")]),t._v(" render触发时机？")]),t._v(" "),_("p",[t._v("在"),_("code",[t._v("React")]),t._v(" 中，类组件只要执行了 "),_("code",[t._v("setState")]),t._v(" 方法，就一定会触发 "),_("code",[t._v("render")]),t._v(" 函数执行")]),t._v(" "),_("p",[t._v("函数组件"),_("code",[t._v("useState")]),t._v(" 会判断当前值有无发生改变确定是否执行"),_("code",[t._v("render")]),t._v("方法，一旦父组件发生渲染，子组件也会渲染")]),t._v(" "),_("h3",{attrs:{id:"如何减少render"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何减少render"}},[t._v("#")]),t._v(" 如何减少render？")]),t._v(" "),_("p",[t._v("父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：")]),t._v(" "),_("ul",[_("li",[t._v("shouldComponentUpdate")]),t._v(" "),_("li",[t._v("PureComponent")]),t._v(" "),_("li",[t._v("React.memo")])]),t._v(" "),_("h3",{attrs:{id:"jsx转化dom过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jsx转化dom过程"}},[t._v("#")]),t._v(" JSX转化DOM过程？")]),t._v(" "),_("div",{staticClass:"language-jsx extra-class"},[_("pre",{pre:!0,attrs:{class:"language-jsx"}},[_("code",[t._v("jsx"),_("span",{pre:!0,attrs:{class:"token template-string"}},[_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("首先会转化成")]),_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("React"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("createElement"),_("span",{pre:!0,attrs:{class:"token template-string"}},[_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("这种形式，\n")]),_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("React"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("createElement"),_("span",{pre:!0,attrs:{class:"token template-string"}},[_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("作用是生成一个虚拟")]),_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("Dom"),_("span",{pre:!0,attrs:{class:"token template-string"}},[_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("对象\n然后会通过")]),_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("ReactDOM"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("render"),_("span",{pre:!0,attrs:{class:"token template-string"}},[_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("进行渲染成真实")]),_("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),_("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DOM")]),t._v("\n")])])]),_("h3",{attrs:{id:"性能优化手段有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化手段有哪些"}},[t._v("#")]),t._v(" 性能优化手段有哪些")]),t._v(" "),_("p",[t._v("除了减少"),_("code",[t._v("render")]),t._v("的渲染之外，还可以通过以下手段进行优化：")]),t._v(" "),_("p",[t._v("除此之外， 常见性能优化常见的手段有如下：")]),t._v(" "),_("ul",[_("li",[t._v("避免使用内联函数")]),t._v(" "),_("li",[t._v("使用 React Fragments 避免额外标记")]),t._v(" "),_("li",[t._v("使用 Immutable")]),t._v(" "),_("li",[t._v("懒加载组件")]),t._v(" "),_("li",[t._v("事件绑定方式")]),t._v(" "),_("li",[t._v("服务端渲染")])]),t._v(" "),_("h3",{attrs:{id:"如何做服务端渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何做服务端渲染"}},[t._v("#")]),t._v(" 如何做服务端渲染？")]),t._v(" "),_("p",[_("code",[t._v("node server")]),t._v(" 接收客户端请求，得到当前的请求"),_("code",[t._v("url")]),t._v(" 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 "),_("code",[t._v("props")]),t._v("、"),_("code",[t._v("context")]),t._v("或者"),_("code",[t._v("store")]),t._v(" 形式传入组件")]),t._v(" "),_("p",[t._v("然后基于 "),_("code",[t._v("react")]),t._v(" 内置的服务端渲染方法 "),_("code",[t._v("renderToString()")]),t._v("把组件渲染为 "),_("code",[t._v("html")]),t._v("字符串在把最终的 "),_("code",[t._v("html")]),t._v("进行输出前需要将数据注入到浏览器端")]),t._v(" "),_("p",[t._v("浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 "),_("code",[t._v("html")]),t._v(" 节点，整个流程结束")]),t._v(" "),_("p",[_("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),t._v(" "),_("p",[t._v("到这里，整个React系列也就结束了，如果这个系列有给你带来一些启发或者帮助，可以点点下方的赞告诉我们，我们下个系列再见")])])}),[],!1,null,null,null);_.default=a.exports}}]);