<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>leetcode最常见的150道前端面试题（简单题上） | duangdong的qa</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端QA集锦">
    <meta name="keywords" content="qd-blog,js,vuepress,leetcode,react,react进阶,css,js进阶,react性能优化,js设计模式">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.07981acf.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/25.9e2d6c46.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/100.ed998eb0.js"><link rel="prefetch" href="/assets/js/101.c8472505.js"><link rel="prefetch" href="/assets/js/102.d600a66c.js"><link rel="prefetch" href="/assets/js/103.c2d41a43.js"><link rel="prefetch" href="/assets/js/104.dc119219.js"><link rel="prefetch" href="/assets/js/105.8707757e.js"><link rel="prefetch" href="/assets/js/106.33c299b9.js"><link rel="prefetch" href="/assets/js/107.8eafcc06.js"><link rel="prefetch" href="/assets/js/108.eeb8c861.js"><link rel="prefetch" href="/assets/js/109.d7579372.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/110.4cdb688a.js"><link rel="prefetch" href="/assets/js/111.95d0f748.js"><link rel="prefetch" href="/assets/js/112.fae5a13a.js"><link rel="prefetch" href="/assets/js/113.7cefcf49.js"><link rel="prefetch" href="/assets/js/114.49f03fa7.js"><link rel="prefetch" href="/assets/js/115.73eebb69.js"><link rel="prefetch" href="/assets/js/116.3b9205f3.js"><link rel="prefetch" href="/assets/js/117.dc4fcb53.js"><link rel="prefetch" href="/assets/js/118.1191553b.js"><link rel="prefetch" href="/assets/js/119.705d33d0.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/120.d3227497.js"><link rel="prefetch" href="/assets/js/121.32bcc7c2.js"><link rel="prefetch" href="/assets/js/122.55a7d973.js"><link rel="prefetch" href="/assets/js/123.07b3f53a.js"><link rel="prefetch" href="/assets/js/124.851c0100.js"><link rel="prefetch" href="/assets/js/125.c1de1f95.js"><link rel="prefetch" href="/assets/js/126.ea96a075.js"><link rel="prefetch" href="/assets/js/127.bcf311b8.js"><link rel="prefetch" href="/assets/js/128.e1c4d95e.js"><link rel="prefetch" href="/assets/js/129.09afee9c.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/130.22372a24.js"><link rel="prefetch" href="/assets/js/131.4db39cda.js"><link rel="prefetch" href="/assets/js/132.afcfdf65.js"><link rel="prefetch" href="/assets/js/133.35b0df52.js"><link rel="prefetch" href="/assets/js/134.9ad9188e.js"><link rel="prefetch" href="/assets/js/135.d7ca4b93.js"><link rel="prefetch" href="/assets/js/136.403dc2de.js"><link rel="prefetch" href="/assets/js/137.f972aed9.js"><link rel="prefetch" href="/assets/js/138.7536ef7d.js"><link rel="prefetch" href="/assets/js/139.05186195.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/140.f7b5e550.js"><link rel="prefetch" href="/assets/js/141.16938126.js"><link rel="prefetch" href="/assets/js/142.0d18982a.js"><link rel="prefetch" href="/assets/js/143.f82390e5.js"><link rel="prefetch" href="/assets/js/144.bac62f6d.js"><link rel="prefetch" href="/assets/js/145.255f2397.js"><link rel="prefetch" href="/assets/js/146.226da4b5.js"><link rel="prefetch" href="/assets/js/147.236f8a9f.js"><link rel="prefetch" href="/assets/js/148.8d472c06.js"><link rel="prefetch" href="/assets/js/149.4170f8c0.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/150.ff7b0269.js"><link rel="prefetch" href="/assets/js/151.0a1c7058.js"><link rel="prefetch" href="/assets/js/152.584c412a.js"><link rel="prefetch" href="/assets/js/153.220d027b.js"><link rel="prefetch" href="/assets/js/154.09a9219e.js"><link rel="prefetch" href="/assets/js/155.6c8dbf71.js"><link rel="prefetch" href="/assets/js/156.a9d81dce.js"><link rel="prefetch" href="/assets/js/157.e53c1adb.js"><link rel="prefetch" href="/assets/js/158.11f55456.js"><link rel="prefetch" href="/assets/js/159.2c05d7f2.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/160.27616923.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.21fe11d7.js"><link rel="prefetch" href="/assets/js/24.7a3e65b2.js"><link rel="prefetch" href="/assets/js/26.0dcf1d19.js"><link rel="prefetch" href="/assets/js/27.bd79a51b.js"><link rel="prefetch" href="/assets/js/28.ad9cdafd.js"><link rel="prefetch" href="/assets/js/29.738a8c4a.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.5d2ae7ae.js"><link rel="prefetch" href="/assets/js/31.2a59449c.js"><link rel="prefetch" href="/assets/js/32.322ed58f.js"><link rel="prefetch" href="/assets/js/33.e18917c7.js"><link rel="prefetch" href="/assets/js/34.edfe8355.js"><link rel="prefetch" href="/assets/js/35.2c0b1e3e.js"><link rel="prefetch" href="/assets/js/36.b1fdf51f.js"><link rel="prefetch" href="/assets/js/37.11ee0b0c.js"><link rel="prefetch" href="/assets/js/38.0b050ca5.js"><link rel="prefetch" href="/assets/js/39.2bd20762.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.eb0c66c8.js"><link rel="prefetch" href="/assets/js/41.933044bc.js"><link rel="prefetch" href="/assets/js/42.eac4ba39.js"><link rel="prefetch" href="/assets/js/43.8c61e37d.js"><link rel="prefetch" href="/assets/js/44.30f132bb.js"><link rel="prefetch" href="/assets/js/45.2477f9bb.js"><link rel="prefetch" href="/assets/js/46.e97df854.js"><link rel="prefetch" href="/assets/js/47.60f16a00.js"><link rel="prefetch" href="/assets/js/48.d01b463f.js"><link rel="prefetch" href="/assets/js/49.e3a15fc7.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.31265493.js"><link rel="prefetch" href="/assets/js/51.ed2cc5dc.js"><link rel="prefetch" href="/assets/js/52.3ae02665.js"><link rel="prefetch" href="/assets/js/53.69d15c58.js"><link rel="prefetch" href="/assets/js/54.bbab20a0.js"><link rel="prefetch" href="/assets/js/55.9617cf7e.js"><link rel="prefetch" href="/assets/js/56.13f9aef2.js"><link rel="prefetch" href="/assets/js/57.ba08cc35.js"><link rel="prefetch" href="/assets/js/58.63028d02.js"><link rel="prefetch" href="/assets/js/59.566c0b50.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.0801f3b3.js"><link rel="prefetch" href="/assets/js/61.ceae0570.js"><link rel="prefetch" href="/assets/js/62.9f28e1a4.js"><link rel="prefetch" href="/assets/js/63.15282044.js"><link rel="prefetch" href="/assets/js/64.7c666983.js"><link rel="prefetch" href="/assets/js/65.320c4670.js"><link rel="prefetch" href="/assets/js/66.253bab14.js"><link rel="prefetch" href="/assets/js/67.49c1e967.js"><link rel="prefetch" href="/assets/js/68.ae82def1.js"><link rel="prefetch" href="/assets/js/69.0877ad54.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/70.5e8208ea.js"><link rel="prefetch" href="/assets/js/71.52cb4845.js"><link rel="prefetch" href="/assets/js/72.8c575d51.js"><link rel="prefetch" href="/assets/js/73.b9ba874e.js"><link rel="prefetch" href="/assets/js/74.6b4693bb.js"><link rel="prefetch" href="/assets/js/75.e9378ce1.js"><link rel="prefetch" href="/assets/js/76.a80b13fc.js"><link rel="prefetch" href="/assets/js/77.d134968d.js"><link rel="prefetch" href="/assets/js/78.40d99cd8.js"><link rel="prefetch" href="/assets/js/79.2b663044.js"><link rel="prefetch" href="/assets/js/80.0b63f3ac.js"><link rel="prefetch" href="/assets/js/81.bc4031db.js"><link rel="prefetch" href="/assets/js/82.3152c02c.js"><link rel="prefetch" href="/assets/js/83.3fa2dc4b.js"><link rel="prefetch" href="/assets/js/84.e778c959.js"><link rel="prefetch" href="/assets/js/85.060ddc49.js"><link rel="prefetch" href="/assets/js/86.bb8138bb.js"><link rel="prefetch" href="/assets/js/87.72c01e68.js"><link rel="prefetch" href="/assets/js/88.e3e56223.js"><link rel="prefetch" href="/assets/js/89.198ff8d1.js"><link rel="prefetch" href="/assets/js/90.6437abb2.js"><link rel="prefetch" href="/assets/js/91.dbe1df52.js"><link rel="prefetch" href="/assets/js/92.6e732f3a.js"><link rel="prefetch" href="/assets/js/93.e98beea7.js"><link rel="prefetch" href="/assets/js/94.c62e88cb.js"><link rel="prefetch" href="/assets/js/95.f6aad986.js"><link rel="prefetch" href="/assets/js/96.e0630547.js"><link rel="prefetch" href="/assets/js/97.3cd76aa5.js"><link rel="prefetch" href="/assets/js/98.3bc2adce.js"><link rel="prefetch" href="/assets/js/99.88c20858.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的qa</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/js/" class="nav-link">
  JS方面
</a></div><div class="nav-item"><a href="/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/summary/" class="nav-link">
  汇总
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  常见算法
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/http/" class="nav-link">
  网络协议
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/face-sutra/" class="nav-link">
  QA
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/js/" class="nav-link">
  JS方面
</a></div><div class="nav-item"><a href="/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/summary/" class="nav-link">
  汇总
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link router-link-active">
  常见算法
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/http/" class="nav-link">
  网络协议
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  CSS
</a></div><div class="nav-item"><a href="/face-sutra/" class="nav-link">
  QA
</a></div><div class="nav-item"><a href="https://link.aduang.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">算法</a></li><li><a href="/algorithm/JavaScript面试中容易遇到的算法.html" class="sidebar-link">JavaScript面试中容易遇到的算法</a></li><li><a href="/algorithm/leetcode最常见的150道前端面试题.html" class="active sidebar-link">leetcode最常见的150道前端面试题（简单题上）</a></li><li><a href="/algorithm/leetcode最常见的150道前端面试题2.html" class="sidebar-link">leetcode 最常见的150道前端面试题（简单题下）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="leetcode最常见的150道前端面试题-简单题上"><a href="#leetcode最常见的150道前端面试题-简单题上" class="header-anchor">#</a> leetcode最常见的150道前端面试题（简单题上）</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/G_SThofkcSUcuX44UbF9kA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/G_SThofkcSUcuX44UbF9kA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="举例-存在重复元素-类似题还有3道-后面一起说-解法一样"><a href="#举例-存在重复元素-类似题还有3道-后面一起说-解法一样" class="header-anchor">#</a> 举例：存在重复元素（类似题还有3道，后面一起说，解法一样）</h2> <p>题目描述如下：</p> <p>给定一个整数数组，判断是否存在重复元素。</p> <p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1:

输入: [1,2,3,1]
输出: true

示例 2:

输入: [1,2,3,4]
输出: false
复制代码
</code></pre></div><p>这题一看就是 计数问题，题目中<code>如果存在一值在数组中出现至少两次</code>，这句话就告诉我们记录每一个数字出现的次数就能解决问题了。</p> <h4 id="解决思路"><a href="#解决思路" class="header-anchor">#</a> 解决思路：</h4> <p>我们遍历数组时，经过数组中的每一项就往map中添加，比如[1,2,3,1]</p> <ul><li>第一项：遍历到第一个1时，对象返回<code>{ 1: 1 }</code>,代表1出现1次</li> <li>第二项：遍历到2时，返回 <code>{ 1: 1, 2: 1 }</code></li> <li>第三项：遍历到3时，返回 <code>{ 1: 1, 2: 1， 3: 1 }</code></li> <li>第四项：遍历到第二个1时，发现原来的对象里已经有1了，返回<code>false</code></li></ul> <p>所以，代码自然也就出来了，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const containsDuplicate = function(nums) {
    let map = new Map();
    for(let i of nums){
        if(map.has(i)){
            return true;
        }else{
            map.set(i, 1);
        }
    }
    return false;
};
复制代码
</code></pre></div><h2 id="哈希表-计数类型"><a href="#哈希表-计数类型" class="header-anchor">#</a> 哈希表 + 计数类型</h2> <p>除了上面的那道题，在最热门的简单题型中还有一些记数类型的题，我们一一解答，这是一类题型</p> <h2 id="_387-字符串中的第一个唯一字符"><a href="#_387-字符串中的第一个唯一字符" class="header-anchor">#</a> 387. 字符串中的第一个唯一字符</h2> <p>一看题目，唯一，条件反射，记数题啊，map走起！我们先看一下题目：</p> <p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p> <div class="language- extra-class"><pre class="language-text"><code>示例：

s = &quot;leetcode&quot;
返回 0

s = &quot;loveleetcode&quot;
返回 2
 
// 提示：你可以假定该字符串只包含小写字母
复制代码
</code></pre></div><p>思路：</p> <ul><li><p>遍历字符串</p></li> <li><p>用一个对象<code>{}</code>来记数，出现过一次就<code>+1</code>，</p></li> <li></li> <li><ul><li>遍历完毕，再次遍历字符串，看它们在之前记录的对象里的值，是否是1，是就返回下标，不是返回-1。</li></ul></li></ul> <p>参考答案：</p> <div class="language- extra-class"><pre class="language-text"><code>var firstUniqChar = function(s) {
  const map = {};
  for(let v of s) map[v] = (map[v] || 0) + 1;
  for(let i = 0; i &lt; s.length; i++) if(map[s[i]] === 1) return i;
  return -1;
};
复制代码
</code></pre></div><h2 id="_242-有效的字母异位词"><a href="#_242-有效的字母异位词" class="header-anchor">#</a> 242. 有效的字母异位词</h2> <p>我们先看一下题目：</p> <p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p> <p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1:

输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
示例 2:

输入: s = &quot;rat&quot;, t = &quot;car&quot;
输出: false
复制代码
</code></pre></div><p>思路：这个题一看字眼，出现次数相同，次数不就是记数吗，记数题型，map走起！</p> <ul><li>声明计数器，一个对象 <code>const obj = {}</code></li> <li>遍历s字符串，如果遍历到字符串的<code>'a'</code>字母，去看<code>obj[a]</code>是否存在</li> <li>不存在说明第一次遍历到<code>'a'</code>字母，那么初始化<code>obj[a] = 1</code></li> <li>如果存在则<code>obj[a] += 1</code></li> <li>t字符串同理，它每次<code>减1</code></li> <li>遍历完s字符串后，遍历obj对象，看它的每一对<code>key：value</code>，是否<code>value</code>都是<code>0</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>var isAnagram = function(s, t) {

  const sLen = s.length;
  const tLen = t.length;
  if(sLen !== tLen ) {
      return false;
  }
  const obj = {};
  for(let i = 0 ; i &lt; sLen ; i++){
      const currentS = s[i];
      const currentT = t[i];
      obj[currentS] ? obj[currentS]++ : obj[currentS] = 1;
      obj[currentT] ? obj[currentT]-- : obj[currentT] = -1;
  }
  return Object.values(obj).every(v=&gt;v===0);
};
复制代码
</code></pre></div><h2 id="_169-多数元素"><a href="#_169-多数元素" class="header-anchor">#</a> 169. 多数元素</h2> <p>我们先看题目（题目里有次数两个字，又是记数题型，map继续走起）：</p> <p>给定一个大小为 <code>n</code> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 <code>⌊ n/2 ⌋</code> 的元素。</p> <p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：[3,2,3]
输出：3
示例 2：

输入：[2,2,1,1,1,2,2]
输出：2
复制代码
</code></pre></div><p>思路：</p> <ul><li>声明一个计数器,也就是一个对象<code>const map = {}</code></li> <li>遍历字符串，开始记数，如果字符串的字母第一次碰见，<code>map[第一次碰见的字母] = 1</code></li> <li>如果map已经记录过这个字母，则<code>map[记录过的的字母] += 1</code></li> <li>在遍历的过程中，看<code>map[记录过的的字母]</code> 是否大于 <code>数组总长度/2</code></li></ul> <p>解答：</p> <div class="language- extra-class"><pre class="language-text"><code>var majorityElement = function(nums) {
  const map = {}
  const n = nums.length &gt;&gt; 1 // &gt;&gt;是右移运算符，意思是除以2
  for(let i = 0; i &lt; nums.length; i++){
      map[nums[i]] = map[nums[i]] !== undefined ? map[nums[i]] + 1 : 1
      if(map[nums[i]] &gt; n) return nums[i]
  }
}
复制代码
</code></pre></div><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="header-anchor">#</a> 只出现一次的数字</h2> <p>这个题一看，出现一次，map走起，但是呢，这个题比较巧的是，因为题目的一些限制条件，可以有更好的解法，我们先看题：</p> <p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p> <p>说明：</p> <p>你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
复制代码
</code></pre></div><p>这里我们用<code>map</code>记录一遍，类似这样的代码，</p> <div class="language- extra-class"><pre class="language-text"><code>const countMap = {};
数组.forEach((item)=&gt; { countMap[item] ? countMap[item] += 1 : countMap[item] = 1 } )
最后再遍历一次countMap，然后看谁的次数是`1`，就解决了
复制代码
</code></pre></div><p>但是这套题有另一个解法，用异或运算符，首先我们看看异或运算符有啥用：</p> <p>异或运算符<code>(^)</code>，我们了解下，这个运算符的功能</p> <ul><li>任何数和自己做异或运算，结果为 <code>0</code>，即 <code>a⊕a=0</code>。</li> <li>任何数和 <code>0</code> 做异或运算，结果还是自己，即 <code>a⊕0=a</code>。</li> <li>异或运算中，满足交换律和结合律，也就是<code>a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</code>。</li></ul> <p>所以出现两次的字母异或运算得<code>0</code>，跟出现一次的字母异或运算得到自己</p> <p>解答：</p> <div class="language- extra-class"><pre class="language-text"><code>var singleNumber = function(nums) {
  let init = nums[0];
  for(let i = 1; i &lt; nums.length; i++){
      init ^=  nums[i];
  }
  return init;
};
复制代码
</code></pre></div><h2 id="位1的个数"><a href="#位1的个数" class="header-anchor">#</a> 位1的个数</h2> <p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
复制代码
</code></pre></div><p>思路：</p> <p>计算个数，按照我们之前的思路，把整个数字转为字符串，类似这样：</p> <div class="language- extra-class"><pre class="language-text"><code>数字 0001 =&gt; String(0001) =&gt; '0001' =&gt; 遍历看1的个数
复制代码
</code></pre></div><p>然后直接遍历计算就可以了，这是我为什么把它归为记数类别的原因，当然也可以把它归为数学类，我们用数学的算法来解，先看答案，我们再解析。</p> <div class="language- extra-class"><pre class="language-text"><code>var hammingWeight = function(n) {
    let ret = 0;
    while(n){
        n &amp;= (n - 1);
        ret++;
    }
    return ret;
};
复制代码
</code></pre></div><p>原理：</p> <p>每执行一次<code>x = x &amp; (x-1)</code>，会将<code>x</code>用二进制表示时最右边的一个<code>1</code>变为<code>0</code>，因为<code>x-1</code>将会将该位(<code>x</code>用二进制表示时最右边的一个<code>1</code>)变为<code>0</code>。因此，对 <code>x</code> 重复该操作，直到 <code>x</code> 变成 <code>0</code>，则操作次数即为 <code>x</code> 的二进制数中的 <code>1</code> 的数目。</p> <p>接下来，我们把其他类型的哈希表题也介绍了（相同的题型没那么多）</p> <h2 id="哈希表-映射功能"><a href="#哈希表-映射功能" class="header-anchor">#</a> 哈希表 + 映射功能</h2> <p>哈希表有一个非常常见的功能就是建立映射关系，比如说设计模式里的策略模式，思路是一样的，映射表常常见于后端的枚举类型，typescript也是一样，我们举一个js的例子</p> <div class="language- extra-class"><pre class="language-text"><code>// 后端只会返回0，1，2
const TYPE = {
    2: 'orange',
    1: 'red',
    0: 'blue'
}

// 然后前端会这样用
TYPE[后端返回的数字0或1或2]
复制代码
</code></pre></div><h3 id="对应的题有"><a href="#对应的题有" class="header-anchor">#</a> 对应的题有：</h3> <ul><li>1.两数之和</li> <li>349.两个数组的交集</li></ul> <h2 id="两数之和"><a href="#两数之和" class="header-anchor">#</a> 两数之和</h2> <p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p> <p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p> <p>你可以按任意顺序返回答案。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]
复制代码
</code></pre></div><p>用 hashMap 存储遍历过的元素和对应的索引。每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。所有事情在一次遍历中完成（用了空间换取时间）</p> <div class="language- extra-class"><pre class="language-text"><code>var twoSum = function(nums, target) {
    const map = new Map();
    for(let i = 0, len = nums.length; i &lt; len; i++){
        if(map.get(nums[i]) !== undefined){
            return [map.get(nums[i]), i];
        } else {
            map.set(target - nums[i], i);
        }
    }
    return [];
};
复制代码
</code></pre></div><h2 id="两数组交集"><a href="#两数组交集" class="header-anchor">#</a> 两数组交集</h2> <p>题目如下：给定两个数组，编写一个函数来计算它们的交集。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 

说明：

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
复制代码
</code></pre></div><p>这道题可以用set，很简单,但是空间复杂度和时间复杂度都太高，不太优雅</p> <div class="language- extra-class"><pre class="language-text"><code>var intersection = function (nums1, nums2) {
    return result =[...new Set(nums1)].filter(item=&gt;new Set(nums2).has(item))
};
复制代码
</code></pre></div><p>我们可以用map来做，时间和空间复杂度都低很多 思路：</p> <ul><li>用一个map去存nums1数组里的每一项，类似<code>map[nums1[i]] = true</code></li> <li>然后去遍历nums2，如果在map中已经有的值，类似<code>map[nums2[i]]</code>, 就把它push到一个数组里</li> <li>并且将map[nums2[i]]设为false，后面有相同的值就不push到数组了</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var intersection = function(nums1, nums2) {
    const map = {};
    const ret = [];
    for(let i = 0; i &lt; nums1.length; i++){
        map[nums1[i]] = true;
    }
    for(let i = 0; i &lt; nums2.length; i++){
        if(map[nums2[i]]){
            ret.push(nums2[i])
            map[nums2[i]] = false
        }
    }
    return ret;
};
复制代码
</code></pre></div><h2 id="找规律题"><a href="#找规律题" class="header-anchor">#</a> 找规律题</h2> <p>这类题一般画个图或者稍微分析一下就能得出答案</p> <h2 id="_13-罗马数字转整数"><a href="#_13-罗马数字转整数" class="header-anchor">#</a> 13. 罗马数字转整数</h2> <p>这个题，我来简单描述一下，罗马数字对应我们阿拉伯数字的map如下：</p> <div class="language- extra-class"><pre class="language-text"><code>        I: 1,
        V: 5,
        IV: 4,
        IX: 9,
        X: 10,
        XL: 40,
        XC: 90,
        L: 50,
        C: 100,
        CD: 400,
        CM: 900,
        D: 500,
        M: 1000,
复制代码
</code></pre></div><p>题目是给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1:

输入: &quot;III&quot;
输出: 3
示例 2:

输入: &quot;IV&quot;
输出: 4
示例 3:

输入: &quot;IX&quot;
输出: 9
示例 4:

输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.
复制代码
</code></pre></div><p>解题思路就是我们发现这些案例的规律，就是把map表里面对应数字加起来就行了，比如说</p> <p><code>&quot;LVIII&quot;</code> = <code>'L'</code>（对应map表50）+ <code>'V'</code>（对应map表5）+ <code>'I'</code>（对应map表1） + <code>'I'</code>对应map表1） + <code>'I'</code>（对应map表1）</p> <p>所以解答就很简单了，就是遍历数字把对应的值加起来，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>var romanToInt = function(s) {
    const map = {
        I: 1,
        V: 5,
        IV: 4,
        IX: 9,
        X: 10,
        XL: 40,
        XC: 90,
        L: 50,
        C: 100,
        CD: 400,
        CM: 900,
        D: 500,
        M: 1000,
    }
    let res = 0;
    let index = 0;
    let len = s.length;
    while(index &lt; len){
        if(index + 1 &lt; len &amp;&amp; map[s.slice(index, index+2)]){
            res += map[s.slice(index, index+2)];
            index += 2;
        }else{
            res += map[s.slice(index, index+1)];
            index += 1;
        }
    }
    return res;
};
复制代码
</code></pre></div><h2 id="_14-最长公共前缀"><a href="#_14-最长公共前缀" class="header-anchor">#</a> 14. 最长公共前缀</h2> <p>题目如下：</p> <p>编写一个函数来查找字符串数组中的最长公共前缀。</p> <p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出：&quot;fl&quot;
示例 2：

输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出：&quot;&quot;
解释：输入不存在公共前缀。
 

提示：

0 &lt;= strs.length &lt;= 200
0 &lt;= strs[i].length &lt;= 200
strs[i] 仅由小写英文字母组成
复制代码
</code></pre></div><p>思路：这个题的思路就是，假如你求数组里3个元素的最长公共前缀</p> <ul><li>你先拿前两个比较，求出他们两个的最长公共前缀</li> <li>然后上面求出的结果去跟第三个元素求最长公共前缀</li> <li>n个元素就一直这么<code>reduce</code>下去</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 这个是求出两个元素最长公共前缀的方法
var longestCommonPrefix = function (strs) {
  if (strs.length === 0) return ''
  if (strs.length === 1) return strs[0];
  return strs.reduce(getSameStr, strs[0]);
};

function getSameStr(a, b) {
  let res = ''
  for (let j = 0; j &lt; a.length; j++) {
    if (a[j] === b[j]) {
      res += a[j];
    } else {
      return res;
    }
  }
  return res
}
复制代码
</code></pre></div><h2 id="_21-合并两个有序链表"><a href="#_21-合并两个有序链表" class="header-anchor">#</a> 21. 合并两个有序链表</h2> <p>这个题简而言之就是看图找规律，就是合并为升序链表，具体题目如下：</p> <p>我们先看一下题目：</p> <p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：


输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
示例 2：

输入：l1 = [], l2 = []
输出：[]
示例 3：

输入：l1 = [], l2 = [0]
输出：[0]
 

提示：

两个链表的节点数目范围是 [0, 50]
-100 &lt;= Node.val &lt;= 100
l1 和 l2 均按 非递减顺序 排列
复制代码
</code></pre></div><p>思路:</p> <p>那就挨个遍历，按顺序谁小拼接谁，接着进入下一轮循环，看代码更清晰一些：</p> <div class="language- extra-class"><pre class="language-text"><code>// 链表定义函数
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

var mergeTwoLists = function(l1, l2) {
  const dummpy = node = new ListNode();
  while(l1 &amp;&amp; l2){
      if(l1.val &gt;= l2.val){
          node.next = l2;
          node = node.next;
          l2 = l2.next;
      } else {
          node.next = l1;
          node = node.next;
          l1 = l1.next;
      }
  }
  node.next = l1 || l2;
  return dummpy.next;
};
复制代码
</code></pre></div><h2 id="_28-实现str"><a href="#_28-实现str" class="header-anchor">#</a> 28. 实现str（）</h2> <p>题目如下：</p> <p>实现 <code>strStr()</code> 函数。</p> <p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 <code>0</code> 开始）。如果不存在，则返回 <code>-1</code> 。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出：2
示例 2：

输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出：-1
示例 3：

输入：haystack = &quot;&quot;, needle = &quot;&quot;
输出：0
 

提示：

0 &lt;= haystack.length, needle.length &lt;= 5 * 104
haystack 和 needle 仅由小写英文字符组成
复制代码
</code></pre></div><p>思路：</p> <p>本来这道题最佳算法是KMP，这个算法理解起来对我来说有难度，所以自己换了另一种思路</p> <ul><li>遍历字符串看是否有和需要找的字符串第一个字母相同</li> <li>如果相同，就截取字符串跟需要找的字符串相同长度的字符串对比</li> <li>相同就返回下标，不同就继续遍历原字符串</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var strStr = function (haystack, needle) {
  if (needle === &quot;&quot;) return 0
  for (var i = 0; i &lt; haystack.length; i++) {
      if (haystack[i] === needle[0]) {
          if (haystack.substring(i, i + needle.length) === needle) return i;
      }
  }
  return -1
};
复制代码
</code></pre></div><h2 id="_118-杨辉三角"><a href="#_118-杨辉三角" class="header-anchor">#</a> 118. 杨辉三角</h2> <p>这个可是找规律的代表题，并且这道题可以训练一下你对<code>二维数组</code> 转化为 <code>代码</code>的能力：</p> <p>给定一个非负整数 <em>numRows，</em> 生成杨辉三角的前 <em>numRows</em> 行。</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p> <p><strong>示例:</strong></p> <div class="language- extra-class"><pre class="language-text"><code>输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
复制代码
</code></pre></div><p>思路：</p> <ul><li>看到上图可以发现，生成杨辉三角<code>numRows</code>行，数组就有<code>numRows</code>行</li> <li>每一行，它的数组第一个位置和最后一个位置都是<code>1</code></li> <li>每一行，除了第一个和最后一个位置，其它位置的值<code>等于上一行的两个值相加</code></li></ul> <p>把思路翻译成代码即可：</p> <div class="language- extra-class"><pre class="language-text"><code>var generate = function(numRows) {
  if(numRows === 0){ return [] }
  const result = Array.from(new Array(numRows), ()=&gt;[])
  for(let i = 0; i &lt; numRows; i++){
    result[i][0] = 1; result[i][i] = 1;
      for(let j = 1; j &lt; i; j++){
      result[i][j] = result[i-1][j-1] + result[i-1][j] 
    }
  }
return result
};
复制代码
</code></pre></div><h2 id="_121-买卖股票的最佳时机"><a href="#_121-买卖股票的最佳时机" class="header-anchor">#</a> 121. 买卖股票的最佳时机</h2> <p>接下来这道题，你简单看下题目就行，解答原理超级简单，看图说话，找规律！</p> <p>我们先看题：</p> <p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p> <p>你只能选择 <code>某一天 买入这只股票，并选择在 未来的某一个不同的日子</code> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p> <p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 &lt;= prices.length &lt;= 105
0 &lt;= prices[i] &lt;= 104
复制代码
</code></pre></div><p>解题思路：我们先看一张图，假设给定的数组为：<code>[7, 1, 5, 3, 6, 4]</code></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <ul><li>第一天是7，我们记录一下，因为还没到第二天不知道这个价格是高是低，<code>标记最小值是7</code></li> <li>第二天是1，<code>比7小</code>，那么只要当前天数的值比前面小，就说明不卖，因为它是最小值，<code>标记最小值是7</code></li> <li>第三天是5，5比前一天大，说明比最小值要大，那么可以卖，利润就是<code>5-1=4</code></li> <li>第四天发现是3，比5小，还是一样的道理，比之前小，最小值就要变为当前值，啥也不干，<code>标记最小值是3</code></li> <li>第五天发现是6...，第六天发现是4，规律是一样的</li></ul> <p>意思是只要今天比昨天低，就可以用今天的减去最小值，就是利润，然后每次都比较这个利润是不是最大就行了</p> <p>结合一下代码，就会清楚</p> <div class="language- extra-class"><pre class="language-text"><code>var maxProfit = function(prices) {
  let res = 0;
  let min = prices[0];
  for(let i = 1; i &lt; prices.length; i++){
      if(prices[i] &lt; min){
          min = prices[i]
      } else {
          res = Math.max(res, prices[i] - min)
      }   
  }
  return res;
};
复制代码
</code></pre></div><h2 id="_122-买卖股票的最佳时机2"><a href="#_122-买卖股票的最佳时机2" class="header-anchor">#</a> 122. 买卖股票的最佳时机2</h2> <p>又来一道看图说话题目，简单！走起！</p> <p>先看题目：</p> <p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p> <p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p> <p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3:

输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
复制代码
</code></pre></div><p>思路，看图马上思路就出来了：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">我们的利润就跟上图绿色部分显示的一样，也就是说只要今天减去昨天，是正数就是利润，简单吧，哈哈！</p> <div class="language- extra-class"><pre class="language-text"><code>var maxProfit = function(prices) {
  let result = 0
  for(let i = 1; i &lt; prices.length; i++){
      if(prices[i] &gt; prices[i-1]){
          result += prices[i] - prices[i - 1]
      }
  }
  return result
};
复制代码
</code></pre></div><h2 id="_206-反转链表"><a href="#_206-反转链表" class="header-anchor">#</a> 206. 反转链表</h2> <p>这个题必须掌握牢实，是解很多链接表题的基础的基础。先看题目：</p> <p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p> <p>示例 1：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <div class="language- extra-class"><pre class="language-text"><code>输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
复制代码
</code></pre></div><p>示例 2：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <div class="language- extra-class"><pre class="language-text"><code>输入：head = [1,2]
输出：[2,1]
复制代码
</code></pre></div><p>解题思路依然是看图找规律，下图就是，我们把链表前面加一个null，这样翻转前和翻转后就一致了。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">解答：</p> <div class="language- extra-class"><pre class="language-text"><code>var reverseList = function(head) {
  let [pre, node] = [null, head];
  while(node){
      const temp = node.next;
      node.next = pre;
      pre = node;
      node = temp;
  }
  return pre;
};
复制代码
</code></pre></div><h2 id="双指针"><a href="#双指针" class="header-anchor">#</a> 双指针</h2> <p>双指针是解数组类型题最常见解法</p> <ul><li>比如有头尾分别有指针，然后依次向中间靠拢的双指针，</li> <li>还有一种是快慢是指针，两个指针都是从左边开始，一个走的快，一个走得慢</li></ul> <p>具体的细节还是需要从题里体会，我们现在就开始！</p> <h2 id="_26-删除数组中的重复项"><a href="#_26-删除数组中的重复项" class="header-anchor">#</a> 26. 删除数组中的重复项</h2> <p>先看一下题目：</p> <p>给你一个有序数组 <code>nums</code> ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p> <p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 

提示：

0 &lt;= nums.length &lt;= 3 * 104
-104 &lt;= nums[i] &lt;= 104
nums 已按升序排列
复制代码
</code></pre></div><p>初始状态是：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <ul><li>慢指针是<code>i</code>，快指针是<code>j</code></li> <li>如果<code>nums[i]</code> 等于 <code>nums[j]</code> 说明是相同的元素，<code>j</code>继续走，<code>i</code>还在原位</li> <li>如果<code>nums[i]</code> 不等于 <code>nums[j]</code> 说明是不相同的元素，那么<code>nums[i++] = nums[j]</code>，<code>j</code>继续向前走</li></ul> <p>依次类推，就相当于<code>i</code>指针保证它和它前面的数字都是不重复的，<code>j</code>就是一个遍历器</p> <div class="language- extra-class"><pre class="language-text"><code>var removeDuplicates = function(nums) {
  let i = 0;
  for(let j = 1; j &lt; nums.length; j++){
      if(nums[j] !== nums[i]){
          nums[i+1] = nums[j];
          i++
      }
  }
  return i + 1
};
复制代码
</code></pre></div><h2 id="_88-合并两个有序数组"><a href="#_88-合并两个有序数组" class="header-anchor">#</a> 88. 合并两个有序数组</h2> <p>我们先看题目：</p> <p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中，使 <code>nums1</code> 成为一个有序数组。</p> <p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
示例 2：

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
 

提示：

nums1.length == m + n
nums2.length == n
0 &lt;= m, n &lt;= 200
1 &lt;= m + n &lt;= 200
-109 &lt;= nums1[i], nums2[i] &lt;= 109
复制代码
</code></pre></div><p>这道题大家很容易想到，新创建一个数组，然后分别比较这两个数组里的每一项，push进去就行了</p> <p>然而因为是有序数组，第一个数组还有正好满足假如第二数组的空间，所以这里可以采取双指针来解答，从后往前遍历</p> <p>参考如下：</p> <div class="language- extra-class"><pre class="language-text"><code>var merge = function (nums1, m, nums2, n) {
  let len = m + n - 1;
  m--, n--;
  while (m &gt;= 0 &amp;&amp; n &gt;= 0) {
    if (nums1[m] &gt; nums2[n]) {
      nums1[len] = nums1[m--]
    } else {
      nums1[len] = nums2[n--]
    }
    len--;
  }
  if(m === -1){
    return nums1.splice(0, len+1, ...nums2.slice(0, n + 1));
  }
  if(n === -1){
    return nums1;
  }
};
复制代码
</code></pre></div><h2 id="_125-验证回文串"><a href="#_125-验证回文串" class="header-anchor">#</a> 125. 验证回文串</h2> <p>请看题目：</p> <p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p> <p>说明：本题中，我们将空字符串定义为有效的回文串。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1:

输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
解释：&quot;amanaplanacanalpanama&quot; 是回文串
示例 2:

输入: &quot;race a car&quot;
输出: false
解释：&quot;raceacar&quot; 不是回文串
复制代码
</code></pre></div><p>这个题太简单了，以至于不用写思路了，看代码就知道，就是用用双指针头尾向中间靠拢的解法，</p> <div class="language- extra-class"><pre class="language-text"><code>var isPalindrome = function(s) {
  s = s.replace(/[^\w]/g, '').toLowerCase();
  let leftPointer = 0;
  let rightPointer = s.length - 1;
  while(rightPointer &gt; leftPointer){
      if(s[leftPointer++] === s[rightPointer--]){
          continue;
      }else{
          return false;
      }
  }
  return true;
};
复制代码
</code></pre></div><h2 id="_234-回文链表"><a href="#_234-回文链表" class="header-anchor">#</a> 234. 回文链表</h2> <p>这个题思路跟上面是一样的，都是双指针对比，但是主要这个题写起来很麻烦，要用到我们之前说的翻转链表，</p> <p>解题思路：</p> <ul><li>先用快慢指针的手法，让我们知道这个链表的中点是哪，然后从中点截断</li> <li>然后截断成为两个链表，把后面的链表翻转</li> <li>最后依次去判断这两个链表每一项是否相同</li></ul> <p>关键点：如何从中点截断这个链表,方法如下，让一个指针每次走一步，另一个指针每次走两步，这样他们每次走的倍数就相差2倍。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>  let fast = head;
  let slow = head;
  let prev;
  while (fast &amp;&amp; fast.next) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
prev.next = null;  // 断成两个链表
复制代码
</code></pre></div><ul><li>接着我们需要翻转链表</li></ul> <div class="language- extra-class"><pre class="language-text"><code> // 翻转后半段
  let head2 = null;
  while (slow) {
    const tmp = slow.next;
    slow.next = head2;
    head2 = slow;
    slow = tmp;
  }
复制代码
</code></pre></div><ul><li>最后对比就看下面具体代码了</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const isPalindrome = (head) =&gt; {
  if (head == null || head.next == null) {
    return true;
  }
  let fast = head;
  let slow = head;
  let prev;
  while (fast &amp;&amp; fast.next) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
  prev.next = null;  // 断成两个链表
  // 翻转后半段
  let head2 = null;
  while (slow) {
    const tmp = slow.next;
    slow.next = head2;
    head2 = slow;
    slow = tmp;
  }
  // 比对
  while (head &amp;&amp; head2) {
    if (head.val != head2.val) {
      return false;
    }
    head = head.next;
    head2 = head2.next;
  }
  return true;
};
复制代码
</code></pre></div><h2 id="_237-删除链表中的节点"><a href="#_237-删除链表中的节点" class="header-anchor">#</a> 237. 删除链表中的节点</h2> <p>题目如下：</p> <p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</p> <p>现有一个链表 -- head = [4,5,1,9]，它可以表示为:</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">image.png</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2：

输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
 

提示：

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。
复制代码
</code></pre></div><p>这个题很简单，其实这个node是个引用类型，你只需要把node的val变为node.next的val，然后node的next指向node.next.next，就移花接木，完成任务了！自己可以试着在草稿上画一下，结合代码很快就会明白！</p> <div class="language- extra-class"><pre class="language-text"><code>var deleteNode = function(node) {
  node.val = node.next.val
  node.next = node.next.next
};
复制代码
</code></pre></div><h2 id="_283-移动零"><a href="#_283-移动零" class="header-anchor">#</a> 283. 移动零</h2> <p>题目如下：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p> <div class="language- extra-class"><pre class="language-text"><code>示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
复制代码
</code></pre></div><p>如动画所示，我们可以用快慢指针来解答，具体不好用语言叙述，看动图</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">show</p> <div class="language- extra-class"><pre class="language-text"><code>var moveZeroes = function(nums) {
  let i = j = 0;
  while(i &lt; nums.length) {
      if(nums[i] !== 0){
          [nums[i], nums[j]] = [nums[j], nums[i]]
          j++
      }
      i++
  }

  return nums
};
复制代码
</code></pre></div><h2 id="_344-反转字符串"><a href="#_344-反转字符串" class="header-anchor">#</a> 344. 反转字符串</h2> <p>题目如下：</p> <p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p> <p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p> <p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
示例 2：

输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
复制代码
</code></pre></div><p>这个题目实在太简单了，知道用首位双指针即可，看参考：</p> <div class="language- extra-class"><pre class="language-text"><code>var reverseString = function(s) {
  let l = 0 ;
  let r = s.length - 1;
  while(l &lt; r){
    [s[l], s[r]] = [s[r], s[l]];
    l++; r--;
  }
  return s;
};
复制代码
</code></pre></div><h2 id="_350-两个数组的交集ii"><a href="#_350-两个数组的交集ii" class="header-anchor">#</a> 350. 两个数组的交集II</h2> <p>题目如下：给定两个数组，编写一个函数来计算它们的交集。</p> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]

说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
我们可以不考虑输出结果的顺序。

复制代码
</code></pre></div><p>这个取交集需要保留重复元素，可以是用双指针来解答，具体思路和代码如下</p> <ul><li><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p></li> <li><p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。</p></li> <li><ul><li>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>var intersect = function(nums1, nums2) {
  nums1 = nums1.sort((a, b) =&gt; a - b);
  nums2 = nums2.sort((a, b) =&gt; a - b);
  let l1 = 0;
  let l2 = 0;
  const nums1Len = nums1.length;
  const nums2Len = nums2.length;
  const ret = [];
  while(l1 &lt; nums1Len &amp;&amp; l2 &lt; nums2Len){
    if(nums1[l1] === nums2[l2]){
      ret.push(nums1[l1]);
      l1++;
      l2++;
    }
    if(nums1[l1] &gt; nums2[l2]) l2++;
    if(nums1[l1] &lt; nums2[l2]) l1++;
  }
  return ret;
};
复制代码
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/JavaScript面试中容易遇到的算法.html" class="prev">
        JavaScript面试中容易遇到的算法
      </a></span> <span class="next"><a href="/algorithm/leetcode最常见的150道前端面试题2.html">
        leetcode 最常见的150道前端面试题（简单题下）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.07981acf.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/25.9e2d6c46.js" defer></script>
  </body>
</html>
